<!doctype html><html lang=en><head><title>How to automate flat-hunting with a Telegram bot :: Walk on the Byte Side</title>
<meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="I am looking for a flat. Looking for a flat is a shitty process. There is a strangely small number of flats in my city and the ones that are available disappear quickly.
I&rsquo;m too lazy to spend all my time looking for a flat. It&rsquo;s not really that complicated, but sometimes I&rsquo;m busy and I forget to look that day, or I&rsquo;m out and it&rsquo;s more hassle with my phone.
"><meta name=keywords content><meta name=robots content="noodp"><link rel=canonical href=https://ander94lakx.github.io/blog/2022-02-05-bot-telegram-find-flat/><script async src="https://www.googletagmanager.com/gtag/js?id=G-EPK628CMMZ"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-EPK628CMMZ")}</script><link rel=stylesheet href=https://ander94lakx.github.io/assets/style.css><link rel=stylesheet href=https://ander94lakx.github.io/assets/green.css><link rel=apple-touch-icon href=https://ander94lakx.github.io/img/apple-touch-icon-192x192.png><link rel="shortcut icon" href=https://ander94lakx.github.io/favicon.ico><meta name=twitter:card content="summary"><meta name=twitter:site content><meta name=twitter:creator content="Ander Granado"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="How to automate flat-hunting with a Telegram bot"><meta property="og:description" content="I am looking for a flat. Looking for a flat is a shitty process. There is a strangely small number of flats in my city and the ones that are available disappear quickly.
I&rsquo;m too lazy to spend all my time looking for a flat. It&rsquo;s not really that complicated, but sometimes I&rsquo;m busy and I forget to look that day, or I&rsquo;m out and it&rsquo;s more hassle with my phone.
"><meta property="og:url" content="https://ander94lakx.github.io/blog/2022-02-05-bot-telegram-find-flat/"><meta property="og:site_name" content="Walk on the Byte Side"><meta property="og:image" content="https://ander94lakx.github.io/favicon.ico"><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><meta property="article:published_time" content="2022-02-05 00:00:00 +0000 UTC"></head><body class=green><div class="container center headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>Walk on the Byte Side</div></a></div><div class=menu-trigger>menu</div></div><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/about>About me</a></li><li><a href=https://twitter.com/andergrma>Twitter</a></li><li><a href=https://www.instagram.com/andergrma/>Instagram</a></li><li><a href=https://github.com/ander94lakx/>GitHub</a></li><li><a href=/pgp>PGP</a></li><div class=spacer></div><ul class=language-selector><ul class=language-selector-current><li>English ▾</li></ul><ul class="language-selector__more hidden"><li><a href=https://ander94lakx.github.io/>English</a></li><li><a href=https://ander94lakx.github.io/es/>Español</a></li></ul></ul></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/about>About me</a></li><li><a href=https://twitter.com/andergrma>Twitter</a></li><li><a href=https://www.instagram.com/andergrma/>Instagram</a></li><li><a href=https://github.com/ander94lakx/>GitHub</a></li><li><a href=/pgp>PGP</a></li><hr><li><a href=https://ander94lakx.github.io/>English</a></li><li><a href=https://ander94lakx.github.io/es/>Español</a></li></ul></nav></header><div class=content><div class=post><h1 class=post-title><a href=https://ander94lakx.github.io/blog/2022-02-05-bot-telegram-find-flat/>How to automate flat-hunting with a Telegram bot</a></h1><div class=post-meta><span class=post-date>2022-02-05
</span><span class=post-author>:: Ander Granado</span>
<span class=post-reading-time>:: 14 min read (2925 words)</span></div><span class=post-tags>#<a href=https://ander94lakx.github.io/tags/bot/>bot</a>&nbsp;
#<a href=https://ander94lakx.github.io/tags/telegram/>telegram</a>&nbsp;
#<a href=https://ander94lakx.github.io/tags/web-scraping/>web-scraping</a>&nbsp;
#<a href=https://ander94lakx.github.io/tags/python/>python</a>&nbsp;</span><div class=post-content><div><p>I am looking for a flat. Looking for a flat is a shitty process. There is a strangely small number of flats in my city and the ones that are available disappear quickly.</p><p>I&rsquo;m too lazy to spend all my time looking for a flat. It&rsquo;s not really that complicated, but sometimes I&rsquo;m busy and I forget to look that day, or I&rsquo;m out and it&rsquo;s more hassle with my phone.</p><p>I&rsquo;ve been wanting to make a Telegram bot for a while now. I didn&rsquo;t know exactly what to do, but the other day I got an idea and I created a bot that tells me about the available flats in my city.</p><p><img alt="Scraping Python Telegram bot" src=/static/images/scraping_telegram_python_bot.jpg title="Scraping Telegram bot made with Python"></p><p>There are two parts involved in this. One is the web scraping part. This is basically automating the extraction of information from websites. Nowadays almost everything is done from the internet and looking for a flat is not going to be any different. Practically all local real estate agencies and individuals who rent flats post their ads on certain platforms (in Spain maily in platforms such as Idealista or Fotocasa), so by consulting there I can see what new options are appearing. It&rsquo;s basically what I was doing so far manually and without enough constancy. Automating it with web scraping allows me to get all that information at a glance.</p><p>The other part is the Telegram bot. Until two days ago I had no idea how it worked. Basically Telegram has a great API so you can do everything with it. You can create bots that run anywhere to communicate directly with users, write in chats or channels and do a lot of things. There is also a very good <a href=https://github.com/python-telegram-bot/python-telegram-bot>wrapper for Python</a> that you can use to interact with the API from Python in a very simple way.</p><h2 id=part-1-web-scraping-with-selenium>Part 1: web scraping with Selenium<a href=#part-1-web-scraping-with-selenium class=hanchor arialabel=Anchor>&#8983;</a></h2><p>It&rsquo;s not the first time I have done web scraping. Some time ago I made a script that allowed to scrape instagram to download all the images of a user. You can have a look at the <a href=https://ander94lakx.github.io/blog/2020-04-25-instagram-bot-python/>post</a> I made or the <a href=https://github.com/ander94lakx/InstaBot>code</a> of the bot (it&rsquo;s a bot, but it&rsquo;s not a Telegram bot).</p><p>When I made that script I used <a href=https://www.selenium.dev/>Selenium</a>, which is probably the best web scraping tool out there. It&rsquo;s not just for that, but it allows you to automate browser operations. With this, you can open websites, browse them, perform actions and extract information from them programmatically. This is much better than directly sending a request with a request handling library, because by actually launching an instance of a browser, you can bypass measures that some websites have in place to block automated mechanisms. The downside is that, since you have to open a browser, you can&rsquo;t run it in an environment that doesn&rsquo;t have a screen (although this can be easily solved with screen-simulating libraries such as <a href=https://pypi.org/project/PyVirtualDisplay/>PyVirtualDisplay</a>).</p><p>With the tools ready and installed, all that remains is to use Selenium to start web scraping. The simpler the scraping the better. In this case, instead of passing the base URL of a flat search site, you can extract the URLs with the parameters to filter the search. In my case, and using Idealista as an example, the URL would be something like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>https://www.idealista.com/alquiler-viviendas/vitoria-gasteiz-alava/?ordenado-por<span style=color:#f92672>=</span>precios-asc
</span></span></code></pre></div><p>As you can see, I am already filtering by my city, and apart from that, I&rsquo;m sorting by price to display the cheapest ones first (there&rsquo;s not much money around here). This could be narrowed down even further. Since most websites of this kind use search parameters in the URL itself (i.e. query parameters, very useful for save as bookmarks later), a lot of scraping work can be saved by simply targeting the endpoint with specific query parameters.</p><p><img alt="Idealista Results" src=/static/images/idealista_web.png title="Search results using Idealista"></p><p>With that in mind, I&rsquo;ve created a simple function that scrapes that page and retrieves flat-related info. I&rsquo;ve also included an option to filter by price (although this is something that can also be done through the URL). The code is as follows:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>scrap_idealista</span>(max_price):
</span></span><span style=display:flex><span>    driver <span style=color:#f92672>=</span> initialize_driver(IDEALISTA_URL)
</span></span><span style=display:flex><span>    scroll_down_and_up(driver)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Be kind and accept the cookies</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>        driver<span style=color:#f92672>.</span>find_element_by_id(<span style=color:#e6db74>&#39;didomi-notice-agree-button&#39;</span>)<span style=color:#f92672>.</span>click()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>except</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>pass</span> <span style=color:#75715e># No cookies button, no problem!</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Find each flat element</span>
</span></span><span style=display:flex><span>    elements <span style=color:#f92672>=</span> driver<span style=color:#f92672>.</span>find_element_by_xpath(<span style=color:#e6db74>&#39;//*[@id=&#34;main-content&#34;]&#39;</span>)
</span></span><span style=display:flex><span>    items <span style=color:#f92672>=</span> elements<span style=color:#f92672>.</span>find_elements_by_class_name(<span style=color:#e6db74>&#39;item-multimedia-container&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    flat_list <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> item <span style=color:#f92672>in</span> items:
</span></span><span style=display:flex><span>        <span style=color:#75715e># Get the link for that flat</span>
</span></span><span style=display:flex><span>        link <span style=color:#f92672>=</span> item<span style=color:#f92672>.</span>find_element_by_xpath(<span style=color:#e6db74>&#39;./div/a[@href]&#39;</span>)
</span></span><span style=display:flex><span>        link <span style=color:#f92672>=</span> link<span style=color:#f92672>.</span>get_attribute(<span style=color:#e6db74>&#39;href&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e># Get the price for that flat</span>
</span></span><span style=display:flex><span>        result <span style=color:#f92672>=</span> re<span style=color:#f92672>.</span>search(<span style=color:#e6db74>&#39;.*</span><span style=color:#ae81ff>\\</span><span style=color:#e6db74>n(.*)€\/mes&#39;</span>, item<span style=color:#f92672>.</span>text)
</span></span><span style=display:flex><span>        price_str <span style=color:#f92672>=</span> result<span style=color:#f92672>.</span>group(<span style=color:#ae81ff>1</span>)<span style=color:#f92672>.</span>replace(<span style=color:#e6db74>&#39;.&#39;</span>, <span style=color:#e6db74>&#39;&#39;</span>)
</span></span><span style=display:flex><span>        price <span style=color:#f92672>=</span> int(price_str)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> price <span style=color:#f92672>&lt;=</span> max_price:
</span></span><span style=display:flex><span>            flat_list<span style=color:#f92672>.</span>append({ 
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#39;link&#39;</span>: link, 
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#39;price&#39;</span>: price,
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#39;image&#39;</span>: item<span style=color:#f92672>.</span>screenshot_as_png, 
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#39;image_name&#39;</span>: item<span style=color:#f92672>.</span>id <span style=color:#f92672>+</span> <span style=color:#e6db74>&#39;.png&#39;</span> 
</span></span><span style=display:flex><span>            })
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    driver<span style=color:#f92672>.</span>quit()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> flat_list
</span></span></code></pre></div><p>Overall, it&rsquo;s quite straightforward to comprehend. First and foremost, the Selenium driver is loaded, and the page is scrolled through entirely. Initially, the web page is loaded to have everything ready to start the search. The scrolling is done because, sometimes, results are loaded as you scroll, so performing a quick scroll before extracting information ensures that all results are actually loaded.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>initialize_driver</span>(url):
</span></span><span style=display:flex><span>    driver <span style=color:#f92672>=</span> webdriver<span style=color:#f92672>.</span>Chrome(executable_path<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;./chromedriver.exe&#39;</span>)
</span></span><span style=display:flex><span>    driver<span style=color:#f92672>.</span>get(url)
</span></span><span style=display:flex><span>    sleep(<span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>    driver<span style=color:#f92672>.</span>set_window_position(<span style=color:#ae81ff>0</span>,<span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    driver<span style=color:#f92672>.</span>set_window_size(<span style=color:#ae81ff>1920</span>, <span style=color:#ae81ff>1080</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> driver
</span></span></code></pre></div><p>Using Selenium is quite straightforward. In this case, I&rsquo;m using the Chrome driver, which I have right in my directory for convenience. After that, I load the URL and set up the window to have a decent size. This is important because elements will be positioned differently depending on the window size. Responsive design is great, but it&rsquo;s one of the worst enemies of a scraper. So, setting a consistent resolution is important to consistently obtain the same results.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>scroll_down_and_up</span>(driver):
</span></span><span style=display:flex><span>    driver<span style=color:#f92672>.</span>execute_script(<span style=color:#e6db74>&#39;window.scrollTo(0, document.body.scrollHeight);&#39;</span>)
</span></span><span style=display:flex><span>    sleep(<span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>    driver<span style=color:#f92672>.</span>execute_script(<span style=color:#e6db74>&#39;window.scrollTo(0, 0);&#39;</span>)
</span></span></code></pre></div><p>Regarding scrolling, there&rsquo;s nothing special here. Just a bit of JS and we&rsquo;re good to go.</p><p>The real deal comes next. Firstly, accepting cookies to navigate the site smoothly and avoid any oddities. This is where the power of Selenium starts to shine.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>driver<span style=color:#f92672>.</span>find_element_by_id(<span style=color:#e6db74>&#39;didomi-notice-agree-button&#39;</span>)<span style=color:#f92672>.</span>click()
</span></span></code></pre></div><p>The element with that ID is selected, in this case a button, and then clicked. The next step is to find the elements with the flat information. Those little cards that appear in a list. Like all elements on a website, they have classes or attributes that identify them.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>elements <span style=color:#f92672>=</span> driver<span style=color:#f92672>.</span>find_element_by_xpath(<span style=color:#e6db74>&#39;//*[@id=&#34;main-content&#34;]&#39;</span>)
</span></span><span style=display:flex><span>items <span style=color:#f92672>=</span> elements<span style=color:#f92672>.</span>find_elements_by_class_name(<span style=color:#e6db74>&#39;item-multimedia-container&#39;</span>)
</span></span></code></pre></div><p>In this case, I&rsquo;ve performed searches using XPath and through class names. If you look at the Idealista website, you can extract this information. It will be different on each website. The great thing about Selenium is that it lets you retrieve elements and then search within them. This way, you can proceed step by step until you reach your intended target.</p><p><img alt="Idealista Scrapping" src=/static/images/idealista_scraping.png title="Elements to find with Selenium"></p><p>Searching through IDs and classes is simple. Searching through XPath is more complex but very powerful. This process can be simplified with an extension like <a href=https://github.com/trembacz/xpath-finder>xPath Finder</a>, which allows you to obtain the XPath of any element on a webpage.</p><p>With that, we now have a list of items, which are each of those little cards. At this point, the next step is to extract the information we want to retrieve.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>for</span> item <span style=color:#f92672>in</span> items:
</span></span><span style=display:flex><span>    <span style=color:#75715e># Get the link for that flat</span>
</span></span><span style=display:flex><span>    link <span style=color:#f92672>=</span> item<span style=color:#f92672>.</span>find_element_by_xpath(<span style=color:#e6db74>&#39;./div/a[@href]&#39;</span>)
</span></span><span style=display:flex><span>    link <span style=color:#f92672>=</span> link<span style=color:#f92672>.</span>get_attribute(<span style=color:#e6db74>&#39;href&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Get the price for that flat</span>
</span></span><span style=display:flex><span>    result <span style=color:#f92672>=</span> re<span style=color:#f92672>.</span>search(<span style=color:#e6db74>&#39;.*</span><span style=color:#ae81ff>\\</span><span style=color:#e6db74>n(.*)€\/mes&#39;</span>, item<span style=color:#f92672>.</span>text)
</span></span><span style=display:flex><span>    price_str <span style=color:#f92672>=</span> result<span style=color:#f92672>.</span>group(<span style=color:#ae81ff>1</span>)<span style=color:#f92672>.</span>replace(<span style=color:#e6db74>&#39;.&#39;</span>, <span style=color:#e6db74>&#39;&#39;</span>)
</span></span><span style=display:flex><span>    price <span style=color:#f92672>=</span> int(price_str)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> price <span style=color:#f92672>&lt;=</span> max_price:
</span></span><span style=display:flex><span>        flat_list<span style=color:#f92672>.</span>append({ 
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#39;link&#39;</span>: link, 
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#39;price&#39;</span>: price,
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#39;image&#39;</span>: item<span style=color:#f92672>.</span>screenshot_as_png
</span></span><span style=display:flex><span>        })
</span></span></code></pre></div><p>There are many ways to achieve this. Selenium allows you to extract the element as an image, which can be useful for sending it in that format later. In my case, I extract the apartment as an image (to send it via Telegram), the price (to check that it doesn&rsquo;t exceed the set limit), and the link (to include alongside each image for accessing the apartments I&rsquo;m interested in). The image name allows me to manage the images for sending them through Telegram.</p><p>And that&rsquo;s it, it&rsquo;s that simple. Now, all that&rsquo;s left is to send this information through Telegram.</p><h2 id=part-2-creating-a-telegram-bot>Part 2: creating a Telegram bot<a href=#part-2-creating-a-telegram-bot class=hanchor arialabel=Anchor>&#8983;</a></h2><p>Crear un bot de Telegram es tan sencillo como usar <a href=https://t.me/botfather>BotFather</a>, el bot que te permite crear bots. Tras crear un bot con él, te da un token que es lo que te permite hacer lo que quieras con la API. La creación del bot es trivial, consiste en hablar con el bot.</p><p>Una vez teniendo un token se puede hacer uso del <a href=https://github.com/python-telegram-bot/python-telegram-bot>wrapper para Python</a> que he mencionado. Instalar con <code>pip</code> y listo. Del wrapper he utilizado lo siguiente:</p><p>Creating a Telegram bot is as simple as using <a href=https://t.me/botfather>BotFather</a>, the bot that allows you to create bots. After creating a bot with it, you will receive a token that enables you to interact with the API. Bot creation is straightforward; it involves having a conversation with the bot.</p><p>Once you have a token, you can utilize the <a href=https://github.com/python-telegram-bot/python-telegram-bot>Python wrapper</a> I mentioned. Install it using pip, and you&rsquo;re all set. From the wrapper, I&rsquo;ve used the following features:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> telegram
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> telegram <span style=color:#f92672>import</span> Bot, Update
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> telegram.ext <span style=color:#f92672>import</span> Updater
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> telegram.ext <span style=color:#f92672>import</span> CallbackContext
</span></span><span style=display:flex><span><span style=color:#f92672>from</span> telegram.ext <span style=color:#f92672>import</span> CommandHandler
</span></span></code></pre></div><p>With it, you can instantiate the bot using the obtained token and create callbacks that allow you to easily listen for commands.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>init</span>():
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>with</span> open(<span style=color:#e6db74>&#39;token.txt&#39;</span>) <span style=color:#66d9ef>as</span> f:
</span></span><span style=display:flex><span>        token <span style=color:#f92672>=</span> f<span style=color:#f92672>.</span>read()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    updater <span style=color:#f92672>=</span> Updater(token<span style=color:#f92672>=</span>token, use_context<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>)
</span></span><span style=display:flex><span>    dispatcher <span style=color:#f92672>=</span> updater<span style=color:#f92672>.</span>dispatcher
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    logging<span style=color:#f92672>.</span>basicConfig(format<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;</span><span style=color:#e6db74>%(asctime)s</span><span style=color:#e6db74> - </span><span style=color:#e6db74>%(name)s</span><span style=color:#e6db74> - </span><span style=color:#e6db74>%(levelname)s</span><span style=color:#e6db74> - </span><span style=color:#e6db74>%(message)s</span><span style=color:#e6db74>&#39;</span>,
</span></span><span style=display:flex><span>                        level<span style=color:#f92672>=</span>logging<span style=color:#f92672>.</span>INFO)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    dispatcher<span style=color:#f92672>.</span>add_handler(CommandHandler(<span style=color:#e6db74>&#39;start&#39;</span>, start))
</span></span><span style=display:flex><span>    dispatcher<span style=color:#f92672>.</span>add_handler(CommandHandler(<span style=color:#e6db74>&#39;bilatu&#39;</span>, bilatu))
</span></span><span style=display:flex><span>    dispatcher<span style=color:#f92672>.</span>add_handler(CommandHandler(<span style=color:#e6db74>&#39;idealista&#39;</span>, idealista))
</span></span><span style=display:flex><span>    dispatcher<span style=color:#f92672>.</span>add_handler(CommandHandler(<span style=color:#e6db74>&#39;fotocasa&#39;</span>, fotocasa))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    updater<span style=color:#f92672>.</span>start_polling()
</span></span></code></pre></div><p>That function is executed when the script starts. I fetch the token from a separate file and create the bot. In the code, you can see that four handlers are created. These are the commands that can be executed with the bot. In this case, they are <code>/start</code>, <code>/bilatu</code> (which means &ldquo;search&rdquo; in Basque), <code>/idealista</code>, and <code>/fotocasa</code>. This way, you can search in all sources or just in a specific one. The functions called with the callbacks are the following:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>bilatu</span>(update: Update, context: CallbackContext):
</span></span><span style=display:flex><span>    scrap(update, context, <span style=color:#e6db74>&#39;all&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>idealista</span>(update: Update, context: CallbackContext):
</span></span><span style=display:flex><span>    scrap(update, context, <span style=color:#e6db74>&#39;idealista&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>fotocasa</span>(update: Update, context: CallbackContext):
</span></span><span style=display:flex><span>    scrap(update, context, <span style=color:#e6db74>&#39;fotocasa&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>scrap</span>(update: Update, context: CallbackContext, site):
</span></span><span style=display:flex><span>    send_initial_message(context, update)
</span></span><span style=display:flex><span>    max_price <span style=color:#f92672>=</span> get_max_price(context)
</span></span><span style=display:flex><span>    flat_list <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> site <span style=color:#f92672>in</span> { <span style=color:#e6db74>&#39;idealista&#39;</span>, <span style=color:#e6db74>&#39;all&#39;</span> }:
</span></span><span style=display:flex><span>        flat_list<span style=color:#f92672>.</span>extend(scrap_idealista(max_price))
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> site <span style=color:#f92672>in</span> { <span style=color:#e6db74>&#39;fotocasa&#39;</span>, <span style=color:#e6db74>&#39;all&#39;</span> }:
</span></span><span style=display:flex><span>        flat_list<span style=color:#f92672>.</span>extend(scrap_fotocasa(max_price))
</span></span><span style=display:flex><span>    send_results(flat_list, update, context)
</span></span><span style=display:flex><span>    send_final_message(context, update)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>send_initial_message</span>(context, update):
</span></span><span style=display:flex><span>    context<span style=color:#f92672>.</span>bot<span style=color:#f92672>.</span>send_message(chat_id<span style=color:#f92672>=</span>update<span style=color:#f92672>.</span>effective_chat<span style=color:#f92672>.</span>id, text<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;Emaidazu minutu bat!&#39;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>send_final_message</span>(context, update):
</span></span><span style=display:flex><span>    context<span style=color:#f92672>.</span>bot<span style=color:#f92672>.</span>send_message(chat_id<span style=color:#f92672>=</span>update<span style=color:#f92672>.</span>effective_chat<span style=color:#f92672>.</span>id, text<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;Hortxe dauzkazu!&#39;</span>)
</span></span></code></pre></div><p>Essentially, different scraping functions are called based on the executed callback. The <code>context</code> and <code>update</code> objects allow you to obtain the bot instance and all the information related to the executed commands (which user executed them, in which chat, group or channel, whether arguments were provided, etc.). In this part, you can also see how simple it is to send a message with a bot using the <code>bot.send_message()</code> function.</p><p>The interesting part of this section is the <code>send_results()</code> function, which takes the output generated by the scraping functions (the list of apartments, each with all the mentioned information) and sends it via Telegram.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>send_results</span>(flat_list: list, update: Update, context: CallbackContext):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> flat <span style=color:#f92672>in</span> flat_list:
</span></span><span style=display:flex><span>        context<span style=color:#f92672>.</span>bot<span style=color:#f92672>.</span>send_photo(chat_id<span style=color:#f92672>=</span>update<span style=color:#f92672>.</span>effective_chat<span style=color:#f92672>.</span>id, caption<span style=color:#f92672>=</span>flat[<span style=color:#e6db74>&#39;link&#39;</span>], photo<span style=color:#f92672>=</span>flat[<span style=color:#e6db74>&#39;image&#39;</span>])
</span></span><span style=display:flex><span>        sleep(<span style=color:#ae81ff>1</span>)
</span></span></code></pre></div><p>This part is also quite straightforward. To send a message, you just need to indicate the chat ID (which is something received in the callbacks to know where the command was called from) and the content you want to send. As seen before, you can send a message with bot.send_message() by providing the chat and the text. In this case, you send the photo of each apartment with bot.send_photo(), specifying the collected image in the photo parameter and the link in the caption parameter.</p><p>With all of this, it&rsquo;s as simple as running it and starting to search for apartments.</p><p><img alt="Telegram Bot" src=/static/images/telegram_bot.png title="Telegram bot searching for flats"></p><p>As it is, it seems quite elegant to me. Taking the entire element as an image allows you to see all the information at a glance, and including the link provides access to the listing for more details or direct contact with the landlord. Another option could have been to capture the text and create a list of apartments with their links, but the first approach appears to be one of the most elegant and certainly the simplest of them all.</p><h2 id=part-3-creating-a-telegram-channel-to-send-the-info-to-it>Part 3: creating a Telegram channel to send the info to it<a href=#part-3-creating-a-telegram-channel-to-send-the-info-to-it class=hanchor arialabel=Anchor>&#8983;</a></h2><p>Sí, con esto no tengo suficiente. Escribir un comando al bot es demasiado trabajo. Por ello, a parte de tener el bot así, he añadido un metodo para que el bot, cada cierto tiempo, escriba en un canal las ofertas que hay. Esto es basicamente lo msimo que hace por ejemplo el <a href=https://t.me/getmanfred>bot de Manfred</a> con las ofertas de trabajo, pero con mayor frecuencia. Además, me gusta como en ese bot no va dejando los mensajes de días anteriores, sino que solo está el último mensaje. Así evita que se llene el canal de mierda y deja que haya solo lo que tiene que haber. Por ello, yo lo he hecho igual.</p><p>That is not enough for me. Typing a command to the bot is too much effort. That&rsquo;s why, in addition to having the bot set up this way, I&rsquo;ve added a method for the bot to periodically post offers in a channel. Essentially, this is similar to what, for instance, the <a href=https://t.me/getmanfred>Manfred bot</a> does with job offers, but with higher frequency. Moreover, I like how that bot doesn&rsquo;t leave messages from previous days; only the latest message remains. This prevents the channel from getting cluttered and keeps only the necessary content. Thus, I&rsquo;ve implemented it the same way.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>update_channel</span>():
</span></span><span style=display:flex><span>    <span style=color:#75715e># Get channel and bot info</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>with</span> open(<span style=color:#e6db74>&#39;token.txt&#39;</span>) <span style=color:#66d9ef>as</span> f:
</span></span><span style=display:flex><span>        token <span style=color:#f92672>=</span> f<span style=color:#f92672>.</span>read()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>with</span> open(<span style=color:#e6db74>&#39;channel_id.txt&#39;</span>) <span style=color:#66d9ef>as</span> f:
</span></span><span style=display:flex><span>        channel_id <span style=color:#f92672>=</span> f<span style=color:#f92672>.</span>read()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    bot <span style=color:#f92672>=</span> telegram<span style=color:#f92672>.</span>Bot(token<span style=color:#f92672>=</span>token)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Remove previously sended messages</span>
</span></span><span style=display:flex><span>    stacked_messages <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>with</span> open(<span style=color:#e6db74>&#39;sent_messages.txt&#39;</span>, <span style=color:#e6db74>&#39;r&#39;</span>) <span style=color:#66d9ef>as</span> f:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> line <span style=color:#f92672>in</span> f<span style=color:#f92672>.</span>readlines():
</span></span><span style=display:flex><span>            stacked_messages<span style=color:#f92672>.</span>append(int(line))
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> stacked_messages:
</span></span><span style=display:flex><span>        bot<span style=color:#f92672>.</span>delete_message(chat_id<span style=color:#f92672>=</span>channel_id, message_id<span style=color:#f92672>=</span>stacked_messages<span style=color:#f92672>.</span>pop())
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Scrap all with the defaul top price</span>
</span></span><span style=display:flex><span>    flat_list <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>    flat_list<span style=color:#f92672>.</span>extend(scrap_idealista(top_price))
</span></span><span style=display:flex><span>    flat_list<span style=color:#f92672>.</span>extend(scrap_fotocasa(top_price))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Send the messages with the info</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e># Saves the message_id of the messages to be able to delete them on the next one</span>
</span></span><span style=display:flex><span>    stacked_messages<span style=color:#f92672>.</span>append(bot<span style=color:#f92672>.</span>send_message(chat_id<span style=color:#f92672>=</span>channel_id, text<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;Kaixo! Hamen dauzkazu oraintxe bertan dauden pisuak:&#39;</span>)<span style=color:#f92672>.</span>message_id)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> flat <span style=color:#f92672>in</span> flat_list:
</span></span><span style=display:flex><span>        stacked_messages<span style=color:#f92672>.</span>append(bot<span style=color:#f92672>.</span>send_photo(chat_id<span style=color:#f92672>=</span>channel_id, caption<span style=color:#f92672>=</span>flat[<span style=color:#e6db74>&#39;link&#39;</span>], photo<span style=color:#f92672>=</span>flat[<span style=color:#e6db74>&#39;image&#39;</span>])<span style=color:#f92672>.</span>message_id)
</span></span><span style=display:flex><span>        sleep(<span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    stacked_messages<span style=color:#f92672>.</span>append(bot<span style=color:#f92672>.</span>send_message(chat_id<span style=color:#f92672>=</span>channel_id, text<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;Hortxe dauzkazu!&#39;</span>)<span style=color:#f92672>.</span>message_id)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>with</span> open(<span style=color:#e6db74>&#39;sent_messages.txt&#39;</span>, <span style=color:#e6db74>&#39;w&#39;</span>) <span style=color:#66d9ef>as</span> f:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> message <span style=color:#f92672>in</span> stacked_messages:
</span></span><span style=display:flex><span>            f<span style=color:#f92672>.</span>write(str(message) <span style=color:#f92672>+</span> <span style=color:#e6db74>&#39;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#39;</span>)
</span></span></code></pre></div><p>I know, this is not the cleanest thing you&rsquo;ve seen in your life. It&rsquo;s basically more of the same but managing the messages that have been sent. Each sent message has a <code>message_id</code>, which is what allows later to be able to delete them. This function basically deletes whatever has been written before in the channel, scrapes the information, sends the information, and saves the <code>message_id</code> to be able to delete the messages next time. It saves those IDs in a file so that, if the bot crashes, they won&rsquo;t be lost and can be deleted when it&rsquo;s restarted, thus not leaving garbage in the channel.</p><p>In this case, it&rsquo;s necessary to create an instance of <code>Bot</code> since it&rsquo;s not received from anywhere. In addition to this, it&rsquo;s necessary to have the ID of the chat or channel where you want to write. There are many bots that allow you to obtain those IDs.</p><p>The idea is to have the script running 24/7 and, in this way, the bot is always ready. On one hand, with the handlers listening, which is done with <code>updater.start_polling()</code> as seen before. On the other hand, there needs to be a way to execute the <code>update_channel()</code> function periodically. For this, we can use <code>schedule</code>, a library that allows you to schedule tasks easily. To install it, use <code>pip</code> and you&rsquo;re done.</p><p>To use it to execute <code>update_channel()</code> at certain intervals, just add the following at the end of the <code>init()</code> function:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>schedule<span style=color:#f92672>.</span>every()<span style=color:#f92672>.</span>hour<span style=color:#f92672>.</span>at(<span style=color:#e6db74>&#34;:00&#34;</span>)<span style=color:#f92672>.</span>do(update_channel)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>while</span> <span style=color:#66d9ef>True</span>:
</span></span><span style=display:flex><span>    schedule<span style=color:#f92672>.</span>run_pending()
</span></span><span style=display:flex><span>    sleep(<span style=color:#ae81ff>1</span>) 
</span></span></code></pre></div><p>As you can see, it&rsquo;s very straightforward to use and the code explains itself. There&rsquo;s no need to worry about the <code>while True</code> loop. The polling of callbacks runs in separate threads, so this doesn&rsquo;t interfere. This keeps it indefinitely checking whether it needs to launch any tasks.</p><p>With all of this in place, all that&rsquo;s left is to let it run somewhere. These kinds of things are perfect for a Raspberry Pi or something similar. It can also be set up on a VPS or wherever suits. The only thing to keep in mind is that it either needs a display or some library like the one mentioned to emulate it. Additionally, the browser that will be used must be installed.</p><p>You can also add more websites for scraping, it&rsquo;s easily scalable. In my case, I use Idealista and Fotocasa, but you can simply add more scraping functions. Obviously, how you retrieve the information will vary from site to site.</p><h2 id=conclusions>Conclusions<a href=#conclusions class=hanchor arialabel=Anchor>&#8983;</a></h2><p>Creating a bot of this kind is a straightforward task, as you can see. The real challenge, however, lies in finding a decent flat that doesn&rsquo;t cost an arm and a leg. That&rsquo;s where the true difficulty lies.</p><p>Developing a bot to retrieve updated information can be very useful. Using web scraping instead of APIs has its advantages. First and foremost, most websites don&rsquo;t offer APIs, so in those cases, there&rsquo;s no other option. Even in cases where APIs are available, they might have limitations. The beauty of web scraping is that it allows you to gather <strong>exactly what you want, in the way you want it</strong>. And let no one deceive you; as long as you&rsquo;re not hammering the website or extracting data massively, there&rsquo;s no wrongdoing here.</p><p>I hope I&rsquo;ve explained myself well and that if you&rsquo;re reading this, it sparks your curiosity to tinker with these topics. As for me, I&rsquo;m not going to stop exploring :)</p><p>Lastly, here&rsquo;s the <a href=https://github.com/ander94lakx/pisu-bot>GitHub repository</a> with the complete code. As always, feel free to do whatever you want with it.</p><p>And remember: <em><strong>Scraping is not a crime!</strong></em></p></div></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Read other posts</span><hr></div><div class=pagination__buttons><span class="button previous"><a href=https://ander94lakx.github.io/blog/2022-02-13-spotify-data-top-songs/><span class=button__icon>←</span>
<span class=button__text>How to get your Top tracks (or whatever info) out of your Spotify account</span>
</a></span><span class="button next"><a href=https://ander94lakx.github.io/blog/2022-01-29-polkit/><span class=button__text>Pwnkit: Vulnerability in Polkit (CVE-2021-4034) in 5 minutes</span>
<span class=button__icon>→</span></a></span></div></div></div></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2024 Powered by <a href=http://gohugo.io>Hugo</a></span>
<span>:: Theme made by <a href=https://twitter.com/panr>panr</a></span></div></div></footer><script src=https://ander94lakx.github.io/assets/main.js></script><script src=https://ander94lakx.github.io/assets/prism.js></script><script src=https://ander94lakx.github.io/assets/languageSelector.js></script></div></body></html>