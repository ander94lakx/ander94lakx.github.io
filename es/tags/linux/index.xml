<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>linux on Walk on the Byte Side</title><link>https://ander94lakx.github.io/es/tags/linux/</link><description>Recent content in linux on Walk on the Byte Side</description><generator>Hugo -- gohugo.io</generator><language>es</language><managingEditor>ander@protonmail.com (Ander Granado)</managingEditor><webMaster>ander@protonmail.com (Ander Granado)</webMaster><lastBuildDate>Thu, 16 Feb 2023 16:00:00 +0100</lastBuildDate><atom:link href="https://ander94lakx.github.io/es/tags/linux/index.xml" rel="self" type="application/rss+xml"/><item><title>Cómo monitorizar dispositivos bluetooth cercanos con un solo comando</title><link>https://ander94lakx.github.io/es/blog/2023-02-15-bluetooth-monitoring-command-linux/</link><pubDate>Thu, 16 Feb 2023 16:00:00 +0100</pubDate><author>ander@protonmail.com (Ander Granado)</author><guid>https://ander94lakx.github.io/es/blog/2023-02-15-bluetooth-monitoring-command-linux/</guid><description>Aspaldiko! Llevaba mucho tiempo sin pasarme por aquí, han sido unos meses con bastante lío (trabajo, mudanza, navidades,&amp;hellip; mil cosas), pero ya era hora de que retomara un poco la actividad en el blog. Aunque todavía tengo que retomar la serie sobre análisis de malware, he decidido que, mientras tanto, voy a ir poniendo algún post sobre alguna cosa que he ido trasteando últimamente, como este, sobre monitorizar dispositivos bluetooth.</description><content>&lt;p>Aspaldiko! Llevaba mucho tiempo sin pasarme por aquí, han sido unos meses con bastante lío (trabajo, mudanza, navidades,&amp;hellip; mil cosas), pero ya era hora de que retomara un poco la actividad en el blog. Aunque todavía tengo que retomar la serie sobre análisis de malware, he decidido que, mientras tanto, voy a ir poniendo algún post sobre alguna cosa que he ido trasteando últimamente, como este, sobre monitorizar dispositivos bluetooth.&lt;/p>
&lt;p>Me encanta Linux. Con la terminal te sientes poderoso. No es que sea un experto en ella, pero cuando te sabes manejar un poco se pueden realizar muchas cosas.&lt;/p>
&lt;p>El otro día quise hacer un pequeño script para monitorizar los dispositivos bluetooth que tengo a mi alrededor. Lo veía como un ejercicio interesante para obtener datos, como saber cuántos dispositivos tengo cerca, ver que tipo de dispositivos son, cuantos dispositivos vienen y van, y ver que se puede hacer con esa información.&lt;/p>
&lt;p>Mi instinto al querer hacer algo del estilo es hacer un script (malditos programadores, siempre &lt;a href="https://www.npmjs.com/package/is-odd">reinventando la rueda&lt;/a>). El lenguaje de scripting con el que más comodo me siento es Python, por lo que pensé en usarlo para hacer esto. Después pensé que, en realidad, lo que quería hacer no era más que usar la salida de un comando (&lt;code>bluetoothctl&lt;/code>), hacer cuatro cosas y volcarlo a un archivo.&lt;/p>
&lt;p>Entoces se me ocurrió que, para eso, lo que debería hacer es más un shell script que usar algo tan &lt;em>overkill&lt;/em> como Python. Así, lo podía usar siempre, menos dependencias, etc.&lt;/p>
&lt;p>Dándole una vuelta más, me planteé si realmente era necesario un script para esto. Lo mismo entre pipes, greps y transformaciones podía hacer un &lt;em>oneline&lt;/em> que pudiera meter en un alias y listo. A veces, cuando busco como obtener cierta info o como hacer ciertas tareas en Linux, los resultados de sitios como &lt;em>Super User&lt;/em> muestran a gente poniendo locuras de comandos para poder hacer todo tipo de virguerías, por lo que pensé que yo podía hacer lo mismo, o al menos intentarlo. Por ello, hoy vengo a explicar cómo montar un comando para monitorizar los dispositivos bluetooth que tengo alrededor.&lt;/p>
&lt;p>Lo primero es lo primero. La herramienta para trabajar con bluetooth que he usado es &lt;code>bluetoothctl&lt;/code>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>bluetoothctl
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://ander94lakx.github.io/static/images/bt-oneline/bt-oneline-1.png" alt="Bluetooth oneliner">&lt;/p>
&lt;p>Si se ejecuta, se ve que funciona en modo interactivo. Para escanear dispositivos simplemente hace falta usar el subcomando &lt;code>scan on&lt;/code> y, con ello, se pone a detectar dispositivos que aparecen, desaparecen o cambian propiedades.&lt;/p>
&lt;p>&lt;img src="https://ander94lakx.github.io/static/images/bt-oneline/bt-oneline-2.png" alt="Bluetooth oneliner">&lt;/p>
&lt;p>Aquí viene el primer problema. Como quiero redirigir la salida de esto, el modo interactivo no me sirve. En Bash (y en otras shells como Zsh, la que uso yo), un &lt;code>--&lt;/code> indica el fin de comandos, tras lo cual solo se puede pasar párametros. Por lo que, si se pone lo siguiente:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>bluetoothctl -- scan on
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://ander94lakx.github.io/static/images/bt-oneline/bt-oneline-3.png" alt="Bluetooth oneliner">&lt;/p>
&lt;p>Ya devuelve todo por salida estándar y sin modo interactivo.&lt;/p>
&lt;p>El siguiente paso es realizar alguna transformación. De primeras, me interesa cortar algunos parámetros, volcar esto y filtrar algunas líneas en función de su contenido. Para esto ya se que lo mejor es usar el avanzado pero intimidante &lt;code>awk&lt;/code>. He visto algunos &lt;a href="https://www.youtube.com/watch?v=W5kr7X7EG4o">videos&lt;/a> sobre él pero no lo he usado nunca más allá de copiapegas. Simplemente por probar, he probado a usar la opción para imprimir lo que devuelve, de la siguiente manera.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>bluetoothctl -- scan on | awk &lt;span style="color:#e6db74">&amp;#39;{print}&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://ander94lakx.github.io/static/images/bt-oneline/bt-oneline-4.png" alt="Bluetooth oneliner">&lt;/p>
&lt;p>Mierda. Otro problema. No sale nada. Mirando en internet, veo que el motivo es un tema de buffers. Como la salida es continua, hasta que no se libera el buffer de &lt;code>bluetoothctl&lt;/code> la salida no se redirige a &lt;code>awk&lt;/code>, por lo que no sirve. También mirando en internet, veo que puedo solucionar esto con &lt;code>stdbuf&lt;/code> y unos argumentos concretos.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>stdbuf -oL bluetoothctl -- scan on | awk &lt;span style="color:#e6db74">&amp;#39;{print}&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://ander94lakx.github.io/static/images/bt-oneline/bt-oneline-5.png" alt="Bluetooth oneliner">&lt;/p>
&lt;p>(No voy a entrar en la explicación detallada de todos los comandos y argumentos, ya que nunca lo voy a poder hacer tan bien como &lt;code>man&lt;/code> u otros internautas anónimos).&lt;/p>
&lt;p>Bien, ahora sí que funciona, así que podemos ponernos serios. Para mostrar solo ciertas partes, se puede usar la sintáxis de dólar, que permite seleccionar ciertos párametros en cada línea de entrada.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>stdbuf -oL bluetoothctl -- scan on &lt;span style="color:#ae81ff">\ &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | awk &lt;span style="color:#e6db74">&amp;#39;{print $1 &amp;#34;,&amp;#34; $3 &amp;#34;,&amp;#34; $4}&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://ander94lakx.github.io/static/images/bt-oneline/bt-oneline-6.png" alt="Bluetooth oneliner">&lt;/p>
&lt;p>Seleccionando el primero, el tercero y el cuarto, se muestran sólamente esos campos. Por defecto, el separador es el espacio, pero si se quiere explicitar o usar cualquier otro, se puede indicar con &lt;code>-F&lt;/code>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>stdbuf -oL bluetoothctl -- scan on &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> | awk -F&lt;span style="color:#e6db74">&amp;#39;[ ]&amp;#39;&lt;/span> &lt;span style="color:#e6db74">&amp;#39;{print $1 &amp;#34;,&amp;#34; $3 &amp;#34;,&amp;#34; $4}&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://ander94lakx.github.io/static/images/bt-oneline/bt-oneline-7.png" alt="Bluetooth oneliner">&lt;/p>
&lt;p>Sabiendo como coger campos, ahora lo que me interesa es coger solo ciertas líneas. Se pueden establecer condiciones para ciertas lineas. Se que las líneas que me interesan son las que tienen &amp;ldquo;Device&amp;rdquo; en el segundo parámetro. Para poner esto en &lt;code>awk&lt;/code>, se expresa antes del comando &lt;code>print&lt;/code> de la siguiente manera:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>stdbuf -oL bluetoothctl -- scan on &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> | awk -F&lt;span style="color:#e6db74">&amp;#39;[ ]&amp;#39;&lt;/span> &lt;span style="color:#e6db74">&amp;#39;$2 ~ /Device/ {print $1 &amp;#34;,&amp;#34; $3 &amp;#34;,&amp;#34; $4}&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://ander94lakx.github.io/static/images/bt-oneline/bt-oneline-8.png" alt="Bluetooth oneliner">&lt;/p>
&lt;p>Incluso se pueden poner varias condiciones, cada una con su regex. En mi caso las líneas que me interesan son las que tengan un &lt;code>[NEW]&lt;/code> o un &lt;code>[DEL]&lt;/code>, que es lo que determina cuando se encuentra un dispositivo y cuando se deja de detectar. Esto, junto a lo de &amp;ldquo;Device&amp;rdquo;, limita perfectamente lo que intento monitorizar. Para poner esto, se pone con &lt;code>&amp;amp;&amp;amp;&lt;/code> y limitando las condiciones entre paréntesis. Como lo que se usan son regex, se usa el single pipe (&lt;code>|&lt;/code>) para decir que vale cualquiera de esos dos valores, quedando así:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>stdbuf -oL bluetoothctl -- scan on &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> | awk -F&lt;span style="color:#e6db74">&amp;#39;[ ]&amp;#39;&lt;/span> &lt;span style="color:#e6db74">&amp;#39;($2 ~ /Device/ &amp;amp;&amp;amp; $1 ~ /[NEW]|[DEL]/) {print $1 &amp;#34;,&amp;#34; $3 &amp;#34;,&amp;#34; $4}&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://ander94lakx.github.io/static/images/bt-oneline/bt-oneline-11.png" alt="Bluetooth oneliner">&lt;/p>
&lt;p>De momento ya va bastante bien, pero de poco me sirve un log si esto no tiene timestamps. &lt;code>awk&lt;/code> es tan potente que puedes usar algunas fuciones dentro de él (no sé si esto es built-in de &lt;code>awk&lt;/code> o no, pero alucinante). En este caso, añado a mi &lt;code>print&lt;/code> una llamada a &lt;code>strftime()&lt;/code> con el formato que me gusta, de la siguiente manera:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>stdbuf -oL bluetoothctl -- scan on &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> | awk -F&lt;span style="color:#e6db74">&amp;#39;[ ]&amp;#39;&lt;/span> &lt;span style="color:#e6db74">&amp;#39;($2 ~ /Device/ &amp;amp;&amp;amp; $1 ~ /[NEW]|[DEL]/) {print strftime(&amp;#34;%Y/%m/%d-%H:%M:%S-%Z&amp;#34;, systime()) &amp;#34;,&amp;#34; $1 &amp;#34;,&amp;#34; $3 &amp;#34;,&amp;#34; $4}&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://ander94lakx.github.io/static/images/bt-oneline/bt-oneline-10.png" alt="Bluetooth oneliner">&lt;/p>
&lt;p>A estas alturas ya estoy sorprendido de lo que se puede hacer con una única linea y juntando comandos (la de lineas de Python que me he ahorrado con esto). Ya, lo ultimo que me falta es volcarlo a un archivo.&lt;/p>
&lt;p>Algo que me interesaba era volcarlo a un archivo pero ir viendo al mismo tiempo la salida. Para esto &lt;code>tee&lt;/code> viene perfecto. Pasamos la salida de &lt;code>awk&lt;/code> a &lt;code>tee&lt;/code> con un pipe y listo:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>stdbuf -oL bluetoothctl -- scan on &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> | awk -F&lt;span style="color:#e6db74">&amp;#39;[ ]&amp;#39;&lt;/span> &lt;span style="color:#e6db74">&amp;#39;($2 ~ /Device/ &amp;amp;&amp;amp; $1 ~ /[NEW]|[DEL]/) {print strftime(&amp;#34;%Y/%m/%d-%H:%M:%S-%Z&amp;#34;, systime()) &amp;#34;,&amp;#34; $1 &amp;#34;,&amp;#34; $3 &amp;#34;,&amp;#34; $4}&amp;#39;&lt;/span> | tee -a bluetooth_scan_log.txt
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://ander94lakx.github.io/static/images/bt-oneline/bt-oneline-12.png" alt="Bluetooth oneliner">&lt;/p>
&lt;p>Mierda. No funciona. Pero espera, esto ya nos suena. Tenemos entre &lt;code>awk&lt;/code> y &lt;code>tee&lt;/code> el mismo problema que teníamos con &lt;code>bluetoothctl&lt;/code> y &lt;code>awk&lt;/code>, así que probamos a solucionarlo de la misma manera y listo:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>stdbuf -oL bluetoothctl -- scan on &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> | stdbuf -oL awk -F&lt;span style="color:#e6db74">&amp;#39;[ ]&amp;#39;&lt;/span> &lt;span style="color:#e6db74">&amp;#39;($2 ~ /Device/ &amp;amp;&amp;amp; $1 ~ /[NEW]|[DEL]/) {print strftime(&amp;#34;%Y/%m/%d-%H:%M:%S-%Z&amp;#34;, systime()) &amp;#34;,&amp;#34; $1 &amp;#34;,&amp;#34; $3 &amp;#34;,&amp;#34; $4}&amp;#39;&lt;/span> &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> | tee -a bluetooth_scan_log.txt
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://ander94lakx.github.io/static/images/bt-oneline/bt-oneline-13.png" alt="Bluetooth oneliner">&lt;/p>
&lt;p>Y listo. Ya tenemos todo el sistema montado. Una vez hecho, he visto que hay varios detalles que corregir, como que quizás coger justo esos parametros no es buena idea ya que el cuarto parametro puede cortarse con espacios, o que igual no me interesa filtrar tanta información.&lt;/p>
&lt;p>De todas maneras, eso no es lo importante. Lo esencial es que, con unos comandos, un poco de prueba error y nuestros amigos Google y &lt;code>man&lt;/code>, se puede montar muchas cosas, sin tener que hacer scripts ni nada. Esto tiene varias ventajas:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Usar herramientas estándar, que están disponibles en la mayoría de distribuciones Linux, lo que asegura poder usarlo en cualquier lado.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Menos scripting. Que no me malinterpretéis, me encanta programar, pero para qué hacerlo si ya hay comandos sólidos y probados que permiten hacerlo. No hay que reinventar la rueda, &lt;em>Keep It Simple, Stupid!&lt;/em>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Poder ponerlo como alias (o función &lt;em>oneline&lt;/em> si las comillas dan muchos problemas) en un &lt;code>.bashrc&lt;/code> (o &lt;code>.zshrc&lt;/code> en mi caso). Ejecutar esto escribiendo una sola palabra te hace sentir muy poderoso.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>Y esto es todo. Sé que, y me he dado cuenta mientras lo hacía, de que hay muchas maneras de mejorar esto. Algunas las he visto, de otras no me habré dado ni cuenta. Mi intención con esto es simplemente mostrar la belleza y la magia de usar herramientas estándar y la terminal, y lo potentes que son este tipo de herramientas para hacer muchas cosas que, al final, no necesitan ser programadas.&lt;/p>
&lt;p>Siempre que vayáis hacer alguna cosa del estilo, plantearos si alguien sería capaz de hacer esto con un comando. Si la respuesta a esa pregunta es sí, buscadlo y, si no lo encontráis, abrid la terminal.&lt;/p>
&lt;p>&lt;em>Happy Hacking!&lt;/em>&lt;/p></content></item><item><title>Pwnkit: Vulnerabilidad en Polkit (CVE-2021-4034) en 5 minutos</title><link>https://ander94lakx.github.io/es/blog/2022-01-29-polkit/</link><pubDate>Sat, 29 Jan 2022 00:00:00 +0000</pubDate><author>ander@protonmail.com (Ander Granado)</author><guid>https://ander94lakx.github.io/es/blog/2022-01-29-polkit/</guid><description>Otro nuevo CVE de los que han dado que hablar. El CVE-2021-4034 salió a la luz hace unos días y se ha esparcido como la pólvora. No es que yo pueda aportar mucho más al tema del que no se haya dicho ya, pero si que puede estar bien hacer un repaso esquemático al CVE y a como explotarlo (que es trivial).
¿Qué es polkit? Polkit es una herramienta que permite controlar los privilegios en sistemas de tipo Unix.</description><content>&lt;p>Otro nuevo CVE de los que han dado que hablar. El &lt;a href="https://nvd.nist.gov/vuln/detail/CVE-2021-4034">CVE-2021-4034&lt;/a> salió a la luz hace unos días y se ha esparcido como la pólvora. No es que yo pueda aportar mucho más al tema del que no se haya dicho ya, pero si que puede estar bien hacer un repaso esquemático al CVE y a como explotarlo (que es trivial).&lt;/p>
&lt;h2 id="qué-es-polkit">¿Qué es polkit?&lt;/h2>
&lt;p>&lt;a href="https://wiki.archlinux.org/title/Polkit">Polkit&lt;/a> es una herramienta que permite controlar los privilegios en sistemas de tipo Unix. Puede controlar la forma en la que los procesos sin privilegios se comunican con procesos con privilegios.&lt;/p>
&lt;p>Esto es util porque hay muchos casos en los que interesa que un proceso interactúe con procesos privilegiados unicamente para determinadas acciones, pero que no pueda hacer otras. En vez de usar algo como sudo (que sería como &amp;ldquo;abrir todas las puertas y a ver que pasa&amp;rdquo;), con Polkit se puede controlar en mayor detalle este tipo de operaciones.&lt;/p>
&lt;h2 id="cuál-es-la-vulnerabilidad">¿Cuál es la vulnerabilidad?&lt;/h2>
&lt;p>Polkit tiene una utilidad llamada &lt;a href="https://linux.die.net/man/1/pkexec">pkexec&lt;/a>. Esta utilidad permite ejecutar comandos como otro usuario o como root. Esta utilidad tiene una vulnerabilidad, ya que no parsea bien el número de parámetros que recibe y permite ejecutar variables de entorno como comandos (!).&lt;/p>
&lt;p>Entonces, según lo que se le pase como variables de entorno, se puede ejecutar código arbitrario. De ahí, se escala privilegios y se consigue permisos de admin, es decir, root.&lt;/p>
&lt;h2 id="cómo-se-puede-explotar-la-vulnerabilidad">¿Cómo se puede explotar la vulnerabilidad?&lt;/h2>
&lt;p>Obviamente, ya hay exploits para ello. Para ver lo fácil que es, se puede poner como ejemplo el exploit de &lt;a href="https://github.com/berdav/CVE-2021-4034">Davide Berardi&lt;/a>. Ponerlo a prueba es tan sencillo como clonar, compilar, ejecutar y win!&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>git clone https://github.com/berdav/CVE-2021-4034
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>make
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>./cve-2021-4034
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Y &lt;em>voilà&lt;/em>! ahí tenéis la consola con root.&lt;/p>
&lt;p>&lt;img src="https://ander94lakx.github.io/static/images/polkit-exploit.png" alt="Polkit exploit" title="Polkit exploit">&lt;/p>
&lt;h2 id="qué-sistemas-son-vulnerables">¿Qué sistemas son vulnerables?&lt;/h2>
&lt;p>Pues diría que prácticamente todos. Aquí no se libra ni el apuntador. Se &lt;a href="https://blog.qualys.com/vulnerabilities-threat-research/2022/01/25/pwnkit-local-privilege-escalation-vulnerability-discovered-in-polkits-pkexec-cve-2021-4034">ha logrado explotar&lt;/a> la vulnerabilidad en instalaciones por defecto de Ubuntu, Debian, Fedora, CentOS y muchas más distribuciones. Al fin y al cabo, teniendo en cuenta que es un componente que se encuentra en prácticamente todas las distribuciones Unix-like.&lt;/p>
&lt;p>Lo peor ya no es eso, sino que la vulnerabilidad lleva &lt;a href="https://gitlab.freedesktop.org/polkit/polkit/-/commit/c8c3d835d24fc4ce5a9c596c7d55d85a0311e8d1">más de 12 años&lt;/a> en el código (!). A mi, personalmente, esta es la parte que me asusta de este tipo de vulnerabilidades, las que llevan desde hace mucho pudiendo ser explotadas, por no poder saber hasta que punto se ha podido hacer uso de ella.&lt;/p>
&lt;h2 id="cómo-mitigar-la-vulnerabilidad">¿Cómo mitigar la vulnerabilidad?&lt;/h2>
&lt;p>Todo el mundo se ha puesto las pilas y han lanzado parches para ello, por lo que a estas alturas, con actualizar a través del gestor de paquetes debería ser suficiente para mitigarla.&lt;/p>
&lt;p>En el mismo repo del exploit que he mostrado hay una version simplemente para probar si se es vulnerable, que se puede probar de la siguiente manera:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>make dry-run
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>dry-run/dry-run-cve-2021-4034
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Otra opción, en caso de que no se pudiera actualizar el sistema, por la razón que fuese (mala idea por cierto, hay que tener siempre actualizados los sistemas), puede ser desactivar el bit SUID de pkexec. Un &lt;code>chmod&lt;/code> para eliminar el bit para todos:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>chmod ug-s /bin/pkexec
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>De esta manera se impide que el exploit pueda escalar privilegios, aunque puede tener muchas consecuencias imprevistas (como en Half Life :)).&lt;/p>
&lt;h2 id="conlusiones">Conlusiones&lt;/h2>
&lt;p>A modo de resumen, os dejo unos puntos que me vienen a la cabeza tras ver una vulnerabilidad de este tipo:&lt;/p>
&lt;ul>
&lt;li>Cuidad vuestras entradas, sobre todo en lenguajes como C y al tratar con elementos a mas bajo nivel.&lt;/li>
&lt;li>Nunca se puede estar completamente seguro. Siempre hay vulnerabilidades que no conocemos pero que pueden ser descubiertas por otros.&lt;/li>
&lt;li>Cuanta más gente este del lado de los buenos, más vulnerabilidades de este tipo se podrán descubrir y con mayor rapidez.
&lt;ul>
&lt;li>Imaginaos las consecuencias de que esto caiga en malas manos (y no solo hablo de cibercriminales ;)).&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>Así que ya sabéis, a actualizar vuestros sistemas!&lt;/p>
&lt;p>Happy hacking!&lt;/p>
&lt;h2 id="exijo-más-detalles">¡Exijo más detalles!&lt;/h2>
&lt;p>Pues aquí los tienes:&lt;/p>
&lt;ul>
&lt;li>El &lt;a href="https://www.qualys.com/2022/01/25/cve-2021-4034/pwnkit.txt">reporte original&lt;/a>.&lt;/li>
&lt;li>Artículo en &lt;a href="https://blog.qualys.com/vulnerabilities-threat-research/2022/01/25/pwnkit-local-privilege-escalation-vulnerability-discovered-in-polkits-pkexec-cve-2021-4034">su blog&lt;/a>.&lt;/li>
&lt;/ul>
&lt;p>&lt;em>PD&lt;/em>: explicaría en detalle la vulnerabilidad, pero creo que ya esta muy bien explicada en cientos de artículos y videos, y no me voy a creer mejor que ellos. Mi objetivo aquí era simplemente hacer un breve resumen de una vulnerabilidad que me ha parecido interesante.&lt;/p></content></item></channel></rss>