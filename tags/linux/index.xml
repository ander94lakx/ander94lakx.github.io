<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>linux on Walk on the Byte Side</title><link>https://ander94lakx.github.io/tags/linux/</link><description>Recent content in linux on Walk on the Byte Side</description><generator>Hugo -- gohugo.io</generator><language>en</language><managingEditor>ander@protonmail.com (Ander Granado)</managingEditor><webMaster>ander@protonmail.com (Ander Granado)</webMaster><lastBuildDate>Thu, 16 Feb 2023 16:00:00 +0100</lastBuildDate><atom:link href="https://ander94lakx.github.io/tags/linux/index.xml" rel="self" type="application/rss+xml"/><item><title>How to monitor nearby bluetooth devices with a single command</title><link>https://ander94lakx.github.io/blog/2023-02-15-bluetooth-monitoring-command-linux/</link><pubDate>Thu, 16 Feb 2023 16:00:00 +0100</pubDate><author>ander@protonmail.com (Ander Granado)</author><guid>https://ander94lakx.github.io/blog/2023-02-15-bluetooth-monitoring-command-linux/</guid><description>Aspaldiko! It&amp;rsquo;s been a long time since I&amp;rsquo;ve been around here, it&amp;rsquo;s been a busy few months (work, moving house, Christmas,&amp;hellip; a thousand things), but it was about time I got back to blogging a bit. Although I still have to continue the series on malware analysis, I&amp;rsquo;ve decided that, in the meantime, I&amp;rsquo;m going to post a few posts about some things I&amp;rsquo;ve been tinkering with lately, like this one, about monitoring bluetooth devices.</description><content>&lt;p>Aspaldiko! It&amp;rsquo;s been a long time since I&amp;rsquo;ve been around here, it&amp;rsquo;s been a busy few months (work, moving house, Christmas,&amp;hellip; a thousand things), but it was about time I got back to blogging a bit. Although I still have to continue the series on malware analysis, I&amp;rsquo;ve decided that, in the meantime, I&amp;rsquo;m going to post a few posts about some things I&amp;rsquo;ve been tinkering with lately, like this one, about monitoring bluetooth devices.&lt;/p>
&lt;p>I love Linux. With linux terminal you feel powerful. It&amp;rsquo;s not that I&amp;rsquo;m an expert using it, but when you know your way around it, you can do a lot of things.&lt;/p>
&lt;p>The other day I wanted to make a small script to monitor the bluetooth devices I have around me. I saw it as an interesting exercise to get data like how many devices I have around, see what kind of devices they are, how many devices are coming and going, and see what can be done with that information.&lt;/p>
&lt;p>My instinct when I wanted to do something like that is to make a script (damn programmers, always &lt;a href="https://www.npmjs.com/package/is-odd">reinventing the wheel&lt;/a>). The scripting language I&amp;rsquo;m most comfortable with is Python, so I thought I&amp;rsquo;d use it to do this. Then I figured that what I really wanted to do was just use the output of a command (&lt;code>bluetoothctl&lt;/code>), do four things and dump it into a file.&lt;/p>
&lt;p>Then I thought that, for that, what I should do is more like a shell script than using something as &lt;em>overkill&lt;/em> as Python. That way, I could use it all the time, less dependencies, etc.&lt;/p>
&lt;p>I wondered if a script was really necessary for this. Maybe between pipes, greps and transformations I could make an &lt;em>oneline&lt;/em> that I could put in an alias and that&amp;rsquo;s it. Sometimes, when I look for how to get certain info or how to do certain tasks in Linux, the results of sites like &lt;em>Super User&lt;/em> show people putting crazy commands to do all kinds of things, so I thought I could do the same, or at least try to do it. So today I&amp;rsquo;m going to explain how to set up a command to monitor the bluetooth devices around me.&lt;/p>
&lt;p>First things first. The bluetooth tool I used is &lt;code>bluetoothctl&lt;/code>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>bluetoothctl
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://ander94lakx.github.io/static/images/bt-oneline/bt-oneline-1.png" alt="Bluetooth oneliner">&lt;/p>
&lt;p>If run, it can be seen that it works in interactive mode. To scan for devices, you simply use the &lt;code>scan on&lt;/code> subcommand, and it starts detecting devices that appear, disappear or change properties.&lt;/p>
&lt;p>&lt;img src="https://ander94lakx.github.io/static/images/bt-oneline/bt-oneline-2.png" alt="Bluetooth oneliner">&lt;/p>
&lt;p>Here comes the first problem. Since I want to redirect the output of this, interactive mode doesn&amp;rsquo;t work for me. In Bash (and other shells like Zsh, which I use), a &lt;code>--&lt;/code> indicates the end of commands, after which you can pass parameters. So, if you put the following:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>bluetoothctl -- scan on
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://ander94lakx.github.io/static/images/bt-oneline/bt-oneline-3.png" alt="Bluetooth oneliner">&lt;/p>
&lt;p>It already returns everything via standard output and without interactive mode.&lt;/p>
&lt;p>The next step is to start doing some transformations. First of all, I want to cut some parameters, dump this and filter some lines according to their content. For this I know that the best way is to use the advanced but intimidating &lt;code>awk&lt;/code>. I have seen some &lt;a href="https://www.youtube.com/watch?v=W5kr7X7EG4o">videos&lt;/a> about it but I have never used it beyond copy-pasting. Just to test it, I&amp;rsquo;ve tried using the option to print what it returns, as follows.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>bluetoothctl -- scan on | awk &lt;span style="color:#e6db74">&amp;#39;{print}&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://ander94lakx.github.io/static/images/bt-oneline/bt-oneline-4.png" alt="Bluetooth oneliner">&lt;/p>
&lt;p>Shit. Another problem. Nothing comes out. Looking on the internet, I see that the reason is a buffering issue. As the output is continuous, until the &lt;code>bluetoothctl&lt;/code> buffer is freed, the output is not redirected to &lt;code>awk&lt;/code>, so it is useless. Also looking on the internet, I see that I can solve this with &lt;code>stdbuf&lt;/code> and some specific arguments.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>stdbuf -oL bluetoothctl -- scan on | awk &lt;span style="color:#e6db74">&amp;#39;{print}&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://ander94lakx.github.io/static/images/bt-oneline/bt-oneline-5.png" alt="Bluetooth oneliner">&lt;/p>
&lt;p>(I will not go into the detailed explanation of all the commands and arguments, as I will never be able to do it as well as &lt;code>man&lt;/code> or other anonymous internet users).&lt;/p>
&lt;p>OK, now it works, so we can get serious. To show only certain parts, you can use the dollar syntax, which allows you to select certain parameters on each input line.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>stdbuf -oL bluetoothctl -- scan on &lt;span style="color:#ae81ff">\ &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | awk &lt;span style="color:#e6db74">&amp;#39;{print $1 &amp;#34;,&amp;#34; $3 &amp;#34;,&amp;#34; $4}&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://ander94lakx.github.io/static/images/bt-oneline/bt-oneline-6.png" alt="Bluetooth oneliner">&lt;/p>
&lt;p>By selecting the first, third and fourth, only those fields are displayed. By default, the separator is the space, but if you want to specify or use any other separator, you can indicate it with &lt;code>-F&lt;/code>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>stdbuf -oL bluetoothctl -- scan on &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> | awk -F&lt;span style="color:#e6db74">&amp;#39;[ ]&amp;#39;&lt;/span> &lt;span style="color:#e6db74">&amp;#39;{print $1 &amp;#34;,&amp;#34; $3 &amp;#34;,&amp;#34; $4}&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://ander94lakx.github.io/static/images/bt-oneline/bt-oneline-7.png" alt="Bluetooth oneliner">&lt;/p>
&lt;p>Knowing how to grab fields, I am now interested in grabbing only certain lines. You can set conditions for certain lines. I know that the lines I am interested in are the ones with &amp;ldquo;Device&amp;rdquo; in the second parameter. To put this in &lt;code>awk&lt;/code>, it is expressed before the &lt;code>print&lt;/code> command as follows:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>stdbuf -oL bluetoothctl -- scan on &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> | awk -F&lt;span style="color:#e6db74">&amp;#39;[ ]&amp;#39;&lt;/span> &lt;span style="color:#e6db74">&amp;#39;$2 ~ /Device/ {print $1 &amp;#34;,&amp;#34; $3 &amp;#34;,&amp;#34; $4}&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://ander94lakx.github.io/static/images/bt-oneline/bt-oneline-8.png" alt="Bluetooth oneliner">&lt;/p>
&lt;p>You can even set several conditions, each with its own regex. In my case, the lines I&amp;rsquo;m interested in are the ones with a &lt;code>[NEW]&lt;/code> or a &lt;code>[DEL]&lt;/code>, which is what determines when a device is found and when it is not detected. This, together with the &amp;ldquo;Device&amp;rdquo;, limits perfectly what I am trying to monitor. To set this, you put it with &lt;code>&amp;amp;&amp;amp;&lt;/code> and limiting conditions in brackets. As regexes are used, the single pipe (&lt;code>|&lt;/code>) is used to say that any of these two values are valid, so it looks like this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>stdbuf -oL bluetoothctl -- scan on &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> | awk -F&lt;span style="color:#e6db74">&amp;#39;[ ]&amp;#39;&lt;/span> &lt;span style="color:#e6db74">&amp;#39;($2 ~ /Device/ &amp;amp;&amp;amp; $1 ~ /[NEW]|[DEL]/) {print $1 &amp;#34;,&amp;#34; $3 &amp;#34;,&amp;#34; $4}&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://ander94lakx.github.io/static/images/bt-oneline/bt-oneline-11.png" alt="Bluetooth oneliner">&lt;/p>
&lt;p>So far so good, but a log is useless if it doesn&amp;rsquo;t have timestamps. &lt;code>awk&lt;/code> is so powerful that you can use some functions inside it (I don&amp;rsquo;t know if this is built-in of &lt;code>awk&lt;/code> or not, but it is amazing). In this case, I add to my &lt;code>print&lt;/code> a call to &lt;code>strftime()&lt;/code> with the format I like, like this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>stdbuf -oL bluetoothctl -- scan on &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> | awk -F&lt;span style="color:#e6db74">&amp;#39;[ ]&amp;#39;&lt;/span> &lt;span style="color:#e6db74">&amp;#39;($2 ~ /Device/ &amp;amp;&amp;amp; $1 ~ /[NEW]|[DEL]/) {print strftime(&amp;#34;%Y/%m/%d-%H:%M:%S-%Z&amp;#34;, systime()) &amp;#34;,&amp;#34; $1 &amp;#34;,&amp;#34; $3 &amp;#34;,&amp;#34; $4}&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://ander94lakx.github.io/static/images/bt-oneline/bt-oneline-10.png" alt="Bluetooth oneliner">&lt;/p>
&lt;p>At this point I&amp;rsquo;m already amazed at what can be done with a single line and by putting commands together (I&amp;rsquo;ve saved so many lines of Python with this). Now, the last thing I need to do is to dump it to a file.&lt;/p>
&lt;p>Something I was interested in was to dump it to a file but to see the output at the same time. For this &lt;code>tee&lt;/code> is perfect. We pass the output from &lt;code>awk&lt;/code> to &lt;code>tee&lt;/code> with a pipe and we&amp;rsquo;re done:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>stdbuf -oL bluetoothctl -- scan on &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> | awk -F&lt;span style="color:#e6db74">&amp;#39;[ ]&amp;#39;&lt;/span> &lt;span style="color:#e6db74">&amp;#39;($2 ~ /Device/ &amp;amp;&amp;amp; $1 ~ /[NEW]|[DEL]/) {print strftime(&amp;#34;%Y/%m/%d-%H:%M:%S-%Z&amp;#34;, systime()) &amp;#34;,&amp;#34; $1 &amp;#34;,&amp;#34; $3 &amp;#34;,&amp;#34; $4}&amp;#39;&lt;/span> | tee -a bluetooth_scan_log.txt
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://ander94lakx.github.io/static/images/bt-oneline/bt-oneline-12.png" alt="Bluetooth oneliner">&lt;/p>
&lt;p>Shit. It doesn&amp;rsquo;t work. But wait, this sounds familiar. We have between &lt;code>awk&lt;/code> and &lt;code>tee&lt;/code> the same problem we had with &lt;code>bluetoothctl&lt;/code> and &lt;code>awk&lt;/code>, so we tried to solve it the same way and that&amp;rsquo;s it:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>stdbuf -oL bluetoothctl -- scan on &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> | stdbuf -oL awk -F&lt;span style="color:#e6db74">&amp;#39;[ ]&amp;#39;&lt;/span> &lt;span style="color:#e6db74">&amp;#39;($2 ~ /Device/ &amp;amp;&amp;amp; $1 ~ /[NEW]|[DEL]/) {print strftime(&amp;#34;%Y/%m/%d-%H:%M:%S-%Z&amp;#34;, systime()) &amp;#34;,&amp;#34; $1 &amp;#34;,&amp;#34; $3 &amp;#34;,&amp;#34; $4}&amp;#39;&lt;/span> &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> | tee -a bluetooth_scan_log.txt
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://ander94lakx.github.io/static/images/bt-oneline/bt-oneline-13.png" alt="Bluetooth oneliner">&lt;/p>
&lt;p>And that&amp;rsquo;s it. Now we have the whole &amp;ldquo;system&amp;rdquo; set up. Once done, I have seen that there are several details to correct, like maybe taking just those parameters is not a good idea because the fourth parameter can be cut with spaces, or maybe I am not interested in filtering so much information.&lt;/p>
&lt;p>Anyway, that&amp;rsquo;s not the important thing. The essential thing is that, with a few commands, a bit of trial and error and our friends Google and &lt;code>man&lt;/code>, you can set up a lot of things, without having to do scripts or anything. This has several advantages:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Use standard tools, which are available in most Linux distributions, which ensures that you can use it everywhere.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Less scripting. Don&amp;rsquo;t get me wrong, I love programming, but why do it if there are already solid and proven commands that allow you to do it. No need to reinvent the wheel, &lt;em>Keep It Simple, Stupid!&lt;/em>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Be able to put it as an alias (or &lt;em>oneline&lt;/em> function if quotes are too much trouble) in a &lt;code>.bashrc&lt;/code> (or &lt;code>.zshrc&lt;/code> in my case). Running this by typing a single word makes you feel very powerful.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>And that is all. I know, and I realised as I was doing it, that there are many ways to improve this. Some I&amp;rsquo;ve seen, some I haven&amp;rsquo;t even realised. My intention with this is just to show the beauty and the magic of using standard tools and the terminal, and how powerful these tools are to do a lot of things that, in the end, don&amp;rsquo;t need to be programmed.&lt;/p>
&lt;p>Whenever you are going to do something like this, ask yourself if someone would be able to do this with a command. If the answer to that question is yes, look for it, and if you can&amp;rsquo;t find it, open the terminal.&lt;/p>
&lt;p>&lt;em>Happy Hacking!&lt;/em>&lt;/p></content></item><item><title>Pwnkit: Vulnerability in Polkit (CVE-2021-4034) in 5 minutes</title><link>https://ander94lakx.github.io/blog/2022-01-29-polkit/</link><pubDate>Sat, 29 Jan 2022 00:00:00 +0000</pubDate><author>ander@protonmail.com (Ander Granado)</author><guid>https://ander94lakx.github.io/blog/2022-01-29-polkit/</guid><description>Another new CVE that has been making headlines. The CVE-2021-4034 was released a few days ago and has spread like wildfire. I can&amp;rsquo;t really contribute much more to the topic that hasn&amp;rsquo;t already been said, but it might be good to give a brief overview of the CVE and how to exploit it (which is trivial).
What is polkit? Polkit is a tool for controlling privileges on Unix-like systems. It can control how unprivileged processes communicate with privileged processes.</description><content>&lt;p>Another new CVE that has been making headlines. The &lt;a href="https://nvd.nist.gov/vuln/detail/CVE-2021-4034">CVE-2021-4034&lt;/a> was released a few days ago and has spread like wildfire. I can&amp;rsquo;t really contribute much more to the topic that hasn&amp;rsquo;t already been said, but it might be good to give a brief overview of the CVE and how to exploit it (which is trivial).&lt;/p>
&lt;h2 id="what-is-polkit">What is polkit?&lt;/h2>
&lt;p>&lt;a href="https://wiki.archlinux.org/title/Polkit">Polkit&lt;/a> is a tool for controlling privileges on Unix-like systems. It can control how unprivileged processes communicate with privileged processes.&lt;/p>
&lt;p>This is useful because there are many cases where a process needs to interact with privileged processes only for certain actions, but not for other ones. Instead of using something like sudo (which would be like &amp;ldquo;open all the doors and see what happens&amp;rdquo;), with Polkit you can control this kind of operations in more detail.&lt;/p>
&lt;h2 id="what-is-the-vulnerability">What is the vulnerability?&lt;/h2>
&lt;p>Polkit has a utility called &lt;a href="https://linux.die.net/man/1/pkexec">pkexec&lt;/a>. This utility allows to execute commands as another user or as root. This utility has a vulnerability, as it does not properly parse the number of parameters it receives and allows environment variables to be executed as commands (!).&lt;/p>
&lt;p>Then, depending on what is passed as environment variables, arbitrary code can be executed. From there, you can escalate privileges and get admin permissions, i.e. root.&lt;/p>
&lt;h2 id="how-can-the-vulnerability-be-exploited">How can the vulnerability be exploited?&lt;/h2>
&lt;p>Obviously, there are already exploits for this. To see how easy it is, you can use [Davide Berardi]&amp;rsquo;s exploit (&lt;a href="https://github.com/berdav/CVE-2021-4034">https://github.com/berdav/CVE-2021-4034&lt;/a>) as an example. Testing it is as easy as clone, compile, run and win!&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>git clone https://github.com/berdav/CVE-2021-4034
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>make
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>./cve-2021-4034
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>And &lt;em>voilà&lt;/em>! there you have the root shell.&lt;/p>
&lt;p>&lt;img src="https://ander94lakx.github.io/static/images/polkit-exploit.png" alt="Polkit exploit" title="Polkit exploit">&lt;/p>
&lt;h2 id="which-systems-are-vulnerable">Which systems are vulnerable?&lt;/h2>
&lt;p>Well, I would say practically all of them. The vulnerability has been &lt;a href="https://blog.qualys.com/vulnerabilities-threat-research/2022/01/25/pwnkit-local-privilege-escalation-vulnerability-discovered-in-polkits-pkexec-cve-2021-4034">successfully exploited&lt;/a> in default installations of Ubuntu, Debian, Fedora, CentOS and many more distributions. After all, it is a component found in practically all Unix-like distributions.&lt;/p>
&lt;p>The worst thing is not only that, but that the vulnerability has been in the code for &lt;a href="https://gitlab.freedesktop.org/polkit/polkit/-/commit/c8c3d835d24fc4ce5a9c596c7d55d85a0311e8d1">more than 12 years&lt;/a> (!). For me, personally, this is the part that scares me about this kind of vulnerability, the ones that have been open to exploitation for a long time, because I don&amp;rsquo;t know to what extent they have been exploited previously.&lt;/p>
&lt;h2 id="how-to-mitigate-the-vulnerability">How to mitigate the vulnerability?&lt;/h2>
&lt;p>Everyone&amp;rsquo;s been doing their best to patch it, so at this point, updating via the package manager should be enough to mitigate it.&lt;/p>
&lt;p>In the same exploit repo that I have shown there is a version just to test if you are vulnerable, which can be tested as follows:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>make dry-run
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>dry-run/dry-run-cve-2021-4034
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Another option, in case of the system could not be updated (bad idea by the way, you should always keep your systems up to date), could be to disable the SUID bit of pkexec. A &lt;code>chmod&lt;/code> to remove the bit for everyone:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>chmod ug-s /bin/pkexec
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>This prevents the exploit from escalating privileges, although it can have many unforeseen consequences (as in Half Life :)).&lt;/p>
&lt;h2 id="conlusions">Conlusions&lt;/h2>
&lt;p>To summarise, here are a few points that come to mind after seeing a vulnerability of this type:&lt;/p>
&lt;ul>
&lt;li>Be careful with your inputs, especially in languages like C and when dealing with lower level elements.&lt;/li>
&lt;li>You can never be completely sure. There are always vulnerabilities that we don&amp;rsquo;t know about but can be discovered by others.&lt;/li>
&lt;li>The more people are on the side of the good guys, the more such vulnerabilities can be discovered, and faster.
&lt;ul>
&lt;li>Imagine the consequences of this falling into the wrong hands (and I&amp;rsquo;m not just talking about cybercriminals ;)).&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>So you know, update your systems!&lt;/p>
&lt;p>Happy hacking!&lt;/p>
&lt;h2 id="i-want-more-details">I want more details!&lt;/h2>
&lt;p>Well, here they are:&lt;/p>
&lt;ul>
&lt;li>The &lt;a href="https://www.qualys.com/2022/01/25/cve-2021-4034/pwnkit.txt">original report&lt;/a>.&lt;/li>
&lt;li>Article in &lt;a href="https://blog.qualys.com/vulnerabilities-threat-research/2022/01/25/pwnkit-local-privilege-escalation-vulnerability-discovered-in-polkits-pkexec-cve-2021-4034">his blog&lt;/a>.&lt;/li>
&lt;/ul>
&lt;p>&lt;em>PS&lt;/em>: I would explain the vulnerability in detail, but I think it&amp;rsquo;s already very well explained in hundreds of articles and videos, and I&amp;rsquo;m not going to think I&amp;rsquo;m better than them. My goal here was simply to make a brief summary of a vulnerability that I found interesting.&lt;/p></content></item></channel></rss>