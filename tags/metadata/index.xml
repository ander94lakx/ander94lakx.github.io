<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>metadata on Walk on the Byte Side</title><link>https://ander94lakx.github.io/tags/metadata/</link><description>Recent content in metadata on Walk on the Byte Side</description><generator>Hugo -- gohugo.io</generator><language>en</language><managingEditor>ander@protonmail.com (Ander Granado)</managingEditor><webMaster>ander@protonmail.com (Ander Granado)</webMaster><lastBuildDate>Sun, 11 Sep 2022 23:30:00 +0200</lastBuildDate><atom:link href="https://ander94lakx.github.io/tags/metadata/index.xml" rel="self" type="application/rss+xml"/><item><title>Malware analysis (II) - Basic static analysis: strings and metadata</title><link>https://ander94lakx.github.io/blog/2022-09-11-malware-analysis-2/</link><pubDate>Sun, 11 Sep 2022 23:30:00 +0200</pubDate><author>ander@protonmail.com (Ander Granado)</author><guid>https://ander94lakx.github.io/blog/2022-09-11-malware-analysis-2/</guid><description>The day has come. It&amp;rsquo;s time to pick up where I left off months ago and continue with the series on malware analysis. This is the second part of an article series. In the previous article, I discussed the basics, different techniques for malware analysis, how to obtain samples, and some basic programs for conducting this type of analysis.
First of all, it&amp;rsquo;s important to remember the different types of analysis that exist.</description><content>&lt;p>The day has come. It&amp;rsquo;s time to pick up where I left off months ago and continue with the series on malware analysis. This is the second part of an article series. In the &lt;a href="../2022-01-26-malware-analysis-1">previous article&lt;/a>, I discussed the basics, different techniques for malware analysis, how to obtain samples, and some basic programs for conducting this type of analysis.&lt;/p>
&lt;p>First of all, it&amp;rsquo;s important to remember the different types of analysis that exist. Basically, they can be divided into four different types:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Static Analysis&lt;/strong>: Involves analysing information about the malware without examining its code or executing it, such as metadata, signatures, format, binary sections, etc.&lt;/li>
&lt;li>&lt;strong>Dynamic Analysis&lt;/strong>: Involves observing the behaviour of the malware while it&amp;rsquo;s running, including interactions with files, system calls, network traffic, registry changes, etc.&lt;/li>
&lt;li>&lt;strong>Code Analysis&lt;/strong>: Involves examining the code and is divided into two types:
&lt;ul>
&lt;li>&lt;strong>Static Code Analysis&lt;/strong>: Analysing the code without executing it.&lt;/li>
&lt;li>&lt;strong>Dynamic Code Analysis&lt;/strong>: Analysing the code while it&amp;rsquo;s running, essentially debugging it.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>There&amp;rsquo;s no strict rule about the order in which to apply these techniques or where to start. However, certain things make more sense to do before others. For instance, analysing code is not the easiest thing to do, so it&amp;rsquo;s not usually the first step. Dynamic analysis requires capturing a lot of information, so if you&amp;rsquo;re doing it locally, it makes sense to have some basic knowledge about the sample being analysed in order to focus your information collection processes: deciding which elements to monitor and prioritizing which information to analyse first.&lt;/p>
&lt;p>The simplest type of analysis that can be performed is &lt;strong>static analysis&lt;/strong>. It doesn&amp;rsquo;t require analysing the code or setting up a range of monitoring programs. Using only static analysis, a lot of information about the file type, interesting metadata, and potential type of malware can be extracted.&lt;/p>
&lt;p>As a result, these techniques are usually the first ones to be applied because they are quick and allow to perform &lt;strong>malware classification&lt;/strong>. What does classifying malware involve? Analysing malware serves two main purposes: firstly, to determine the type of malware and where it fits within the broader landscape of existing malware (&amp;ldquo;family&amp;rdquo; of malware it belongs to), and secondly, to understand its behaviour and learn from it. The former is what&amp;rsquo;s called classification.&lt;/p>
&lt;p>This is because, in general, malware samples tend to be variations of other samples. In programming, the more you can recycle, the better, and malware is no exception. Searching for patterns, signatures, and characteristics that have been found in other samples allows us to identify the type of malware much earlier than having to examine its code or behaviour, saving a lot of time. Furthermore, if the type of malware is known, analysing its code becomes easier (since you already know the features and peculiarities you&amp;rsquo;re looking for), and you can already have hints about its behaviour based on how similar malware behaves.&lt;/p>
&lt;h1 id="requirements">Requirements&lt;/h1>
&lt;p>With all this in mind, let&amp;rsquo;s see how we can obtain basic information from a sample. For this, obviously, a malware sample is required. I&amp;rsquo;m going to use one that I analysed in the past, a &lt;a href="https://bazaar.abuse.ch/sample/7faeb64c50cd15d036ca259a047d6c62ed491fff3729433fefba0b02c059d5ed/">Ryuk ransomware&lt;/a> sample. The SHA-256 hash of the sample is as follows:&lt;/p>
&lt;pre tabindex="0">&lt;code>7faeb64c50cd15d036ca259a047d6c62ed491fff3729433fefba0b02c059d5ed
&lt;/code>&lt;/pre>&lt;p>Any sample will do for this purpose, but the results will vary depending on the sample used. Obviously, since samples obtained from malware repositories like this one are already known, we&amp;rsquo;ve essentially spoiled what kind of sample it is. Analysing an unknown sample would not have this advantage. Nevertheless, the interesting part is to see to what extent we can extract information from the sample ourselves.&lt;/p>
&lt;p>On the other hand, a secure environment is necessary to analyze the sample. To achieve this, a virtualized environment is required. The previous article mentioned several options. Even though the sample is for Windows in this case, this part can be done with both Linux and Windows machines, as for now, we&amp;rsquo;re not going to execute anything. For the dynamic analysis part, a Windows virtual machine is needed. In my case, to showcase a bit of both, I&amp;rsquo;m going to use both a Windows and a Linux virtual machine, specifically Remnux. I like to combine both as there are tools that are only available on one system or the other. Additionally, I&amp;rsquo;m more comfortable with the Linux terminal, but sometimes I prefer certain programs on Windows. As long as we use the same sample on both machines, there&amp;rsquo;s no issue. We can verify that we have the same sample on both by checking the integrity of the sample using its hash.&lt;/p>
&lt;p>With this in place, let&amp;rsquo;s begin diving into the sample.&lt;/p>
&lt;h1 id="obtaining-the-hashes">Obtaining the hashes&lt;/h1>
&lt;p>The first step is to calculate the hashes of the sample. If obtained from a repository, you already have the hash, and it&amp;rsquo;s just a matter of verifying it for integrity purposes, i.e., ensuring that you have the desired sample. This can be done with various tools such as 7Zip or HashCalc for Windows, or you can use built-in commands available on certain systems, like most Linux distributions.&lt;/p>
&lt;p>&lt;img src="https://ander94lakx.github.io/static/images/malware-2-hashes-linux.png" alt="Linux Hashes" title="Hash calculation in Linux">&lt;/p>
&lt;p>If using multiple machines, it&amp;rsquo;s recommended to perform this step on all of them to ensure consistency across the loaded samples.&lt;/p>
&lt;p>&lt;img src="https://ander94lakx.github.io/static/images/malware-2-hashes-windows.png" alt="Windows Hashes" title="Hash calculation in Windows">&lt;/p>
&lt;p>Okay, now we have the sample on our system and ready for analysis. Where should we start?&lt;/p>
&lt;p>In reality, as I mentioned before, there&amp;rsquo;s no defined order for this, but there are some basic processes that can be done quickly and tend to be among the first steps taken. These steps are chosen due to their simplicity as well as the information they might provide for more complex types of analysis, like code or behavioural analysis. In this part, we&amp;rsquo;ll cover a couple of basic static analysis techniques: &lt;strong>analysing strings and metadata&lt;/strong>.&lt;/p>
&lt;h1 id="file-type">File Type&lt;/h1>
&lt;p>Even though we know in this case that it&amp;rsquo;s a malware sample for Windows, it&amp;rsquo;s generally a good practice to determine the type of sample you&amp;rsquo;re dealing with. If the sample were unknown, this could help us understand whether it&amp;rsquo;s a binary or not, and for the former case, which architecture and operating system it&amp;rsquo;s intended for. Depending on this, different machines, tools, and techniques might be required. The simplest way is to use something like the &lt;code>file&lt;/code> command in Linux.&lt;/p>
&lt;p>&lt;img src="https://ander94lakx.github.io/static/images/malware-2-file.png" alt="File Type" title="File Type">&lt;/p>
&lt;p>This confirms what we already knew, that it&amp;rsquo;s a 32-bit Windows executable. It&amp;rsquo;s mentioned that it&amp;rsquo;s a PE32 executable. Later on, we&amp;rsquo;ll delve into the details of the PE32 binary format and how to analyze its structure in more detail to extract information about this type of sample. For now, since we know it&amp;rsquo;s a binary, let&amp;rsquo;s try to extract its strings.&lt;/p>
&lt;h1 id="strings-analysis">Strings Analysis&lt;/h1>
&lt;p>Anyone who has ever programmed has had to read code.&lt;/p>
&lt;p>In fact, most of the time, developers spend more time reading code than writing it. Any programmer with even a bit of experience has sat down in front of some codebase to understand how a program works because they&amp;rsquo;ve been handed a project at work, forked a project to extend it, or are reading a Stack Overflow answer. Regardless of the reason, one of the easiest ways to understand what code does is to look at the messages it displays or the strings it contains. Those prints and logs that gives info to users and developers also gives info to other programmers. Therefore, one of the most basic things you can do when analysing malware is to analyze strings.&lt;/p>
&lt;p>However, there&amp;rsquo;s an issue. Usually, the malware samples you&amp;rsquo;ll encounter are compiled samples. They won&amp;rsquo;t make your day by showing you their code. So, how do you do it? Reverse engineering?&lt;/p>
&lt;p>Yes and no. Although reverse engineering can yield disassembled code or even higher-level code, it&amp;rsquo;s not yet necessary. A string is essentially a sequence of bytes with a specific encoding, such as ASCII or UTF-8. By attempting to interpret the bytes using a specific encoding to see if we get readable text, we can potentially find strings.&lt;/p>
&lt;p>Obviously, we shouldn&amp;rsquo;t do this manually. There are many tools for this purpose. Many hexadecimal editors offer string search options. On Windows, the easiest way is to use &lt;strong>&lt;code>strings.exe&lt;/code>&lt;/strong>, a &lt;a href="https://docs.microsoft.com/en-us/sysinternals/">SysInternal&lt;/a> tool for Windows that extracts strings from a binary. SysInternals tools are powerful tools for both Windows system administrators and malware analysts. Having them in your toolbox is a must. The equivalent of this tool on Linux is the &lt;code>strings&lt;/code> command.&lt;/p>
&lt;p>Running it on the binary will show the detected strings (I&amp;rsquo;ve shortened the output as it generates a lot of noise and false positives).&lt;/p>
&lt;pre tabindex="0">&lt;code>!This program cannot be run in DOS mode.
.text
.rdata
@.data
.rsrc
DllUnregisterServer
catsrv.dll
IsProcessorFeaturePresent
GlobalUnlock
GetUserDefaultUILanguage
GetCurrentProcess
QueryPerformanceCounter
GetFileAttributesW
LoadLibraryExW
CloseHandle
InitializeCriticalSectionAndSpinCount
InitializeSListHead
GetCurrentThreadId
LoadLibraryA
TerminateProcess
CreateEventW
GetModuleHandleW
GetProcAddress
SetUnhandledExceptionFilter
VirtualProtectEx
UnhandledExceptionFilter
GlobalAlloc
GlobalLock
DeleteCriticalSection
IsDebuggerPresent
GetModuleFileNameW
GetCurrentProcessId
GetLastError
OutputDebugStringW
GetStartupInfoW
kernel32.dll
DllGetClassObject
msident.dll
CoUninitialize
CoInitialize
CoCreateGuid
ole32.dll
UuidCreate
rpcrt4.dll
CloseClipboard
EnableWindow
DrawIcon
IsIconic
EmptyClipboard
OpenClipboard
GetClientRect
SendMessageW
GetSystemMenu
GetParent
GetForegroundWindow
SetClipboardData
LoadIconW
AppendMenuW
GetSystemMetrics
user32.dll
&amp;lt;?xml version=&amp;#39;1.0&amp;#39; encoding=&amp;#39;UTF-8&amp;#39; standalone=&amp;#39;yes&amp;#39;?&amp;gt;
&amp;lt;assembly xmlns = &amp;#39;urn:schemas-microsoft-com:asm.v1&amp;#39; manifestVersion = &amp;#39;1.0&amp;#39;&amp;gt;
&amp;lt;trustInfo xmlns = &amp;#34;urn:schemas-microsoft-com:asm.v3&amp;#34;&amp;gt;
&amp;lt;security&amp;gt;
&amp;lt;requestedPrivileges&amp;gt;
&amp;lt;requestedExecutionLevel level = &amp;#39;asInvoker&amp;#39; uiAccess = &amp;#39;false&amp;#39; /&amp;gt;
&amp;lt;/requestedPrivileges&amp;gt;
&amp;lt;/security&amp;gt;
&amp;lt;/trustInfo&amp;gt;
&amp;lt;/assembly&amp;gt;
VeriSign, Inc.1+0)
&amp;#34;VeriSign Time Stamping Services CA0
070615000000Z
120614235959Z0\1
VeriSign, Inc.1402
+VeriSign Time Stamping Services Signer - G20
http://ocsp.verisign.com0
&amp;#34;http://crl.verisign.com/tss-ca.crl0
TSA1-20
Western Cape1
Durbanville1
Thawte1
Thawte Certification1
Thawte Timestamping CA0
031204000000Z
131203235959Z0S1
VeriSign, Inc.1+0)
&amp;#34;VeriSign Time Stamping Services CA0
http://ocsp.verisign.com0
0http://crl.verisign.com/ThawteTimestampingCA.crl0
TSA2048-1-530
VeriSign, Inc.1
VeriSign Trust Network1;09
2Terms of use at https://www.verisign.com/rpa (c)09100.
&amp;#39;VeriSign Class 3 Code Signing 2009-2 CA0
Moscow1
Moscow1
Kaspersky Lab1&amp;gt;0&amp;lt;
5Digital ID Class 3 - Microsoft Software Validation v21
Technical dept1
Kaspersky Lab0
3http://csc3-2009-2-crl.verisign.com/CSC3-2009-2.crl0D
https://www.verisign.com/rpa0
http://ocsp.verisign.com0?
3http://csc3-2009-2-aia.verisign.com/CSC3-2009-2.cer0
VeriSign, Inc.1705
.Class 3 Public Primary Certification Authority0
090521000000Z
190520235959Z0
VeriSign, Inc.1
VeriSign Trust Network1;09
2Terms of use at https://www.verisign.com/rpa (c)09100.
&amp;#39;VeriSign Class 3 Code Signing 2009-2 CA0
https://www.verisign.com/cps0*
https://www.verisign.com/rpa0
#http://logo.verisign.com/vslogo.gif0
http://ocsp.verisign.com01
http://crl.verisign.com/pca3.crl0)
Class3CA2048-1-550
xEv1
Washington1
Redmond1
Microsoft Corporation1)0&amp;#39;
Microsoft Code Verification Root0
060523170129Z
160523171129Z0_1
VeriSign, Inc.1705
.Class 3 Public Primary Certification Authority0
Dhttp://crl.microsoft.com/pki/crl/products/MicrosoftCodeVerifRoot.crl0
VeriSign, Inc.1
VeriSign Trust Network1;09
2Terms of use at https://www.verisign.com/rpa (c)09100.
&amp;#39;VeriSign Class 3 Code Signing 2009-2 CA
VeriSign, Inc.1+0)
&amp;#34;VeriSign Time Stamping Services CA
100907170408Z0#
&lt;/code>&lt;/pre>&lt;p>There are strings that will almost always appear, like the DOS headers (the &lt;code>&amp;quot;!This program cannot be run in DOS mode&amp;quot;&lt;/code> is a compatibility mechanism from Microsoft that has been present for decades) or some that are simply false positives. What&amp;rsquo;s interesting is to see if any of these strings provide information about what the binary does.&lt;/p>
&lt;p>Among all the observed strings, you can notice two types of strings:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>References to libraries and functions&lt;/strong>: In a binary, it&amp;rsquo;s common to find references to functions from external libraries, as programs often need external libraries (whether from the system or not) to perform certain tasks. These functions can provide hints about the capabilities of the binary—what things it can do. For example, if it contains functions to interact with files, it can interact with files. However, this doesn&amp;rsquo;t show all the capabilities a binary might have, as there are ways to hide this, which we&amp;rsquo;ll see later.&lt;/li>
&lt;li>&lt;strong>Information about certificates&lt;/strong> (mentions of VeriSign, Microsoft, etc.): This might indicate that the binary is signed. Signing a binary is a way to evade antivirus systems. We can verify if it&amp;rsquo;s signed using various tools.&lt;/li>
&lt;/ul>
&lt;p>As you can see in this case, unfortunately, the strings don&amp;rsquo;t seem to provide much information about what the binary does. No strings specific to the program, like output messages or program variables, have been detected. In such cases, there are two possibilities: either the sample doesn&amp;rsquo;t contain interesting strings, or they are obfuscated. Regardless, it&amp;rsquo;s always a good idea to try various methods for string extraction. Using SysInternal&amp;rsquo;s tool is the simplest approach. If you use different applications, like PEStudio, and compare the results among them, you might get more insights.&lt;/p>
&lt;p>But if the strings are obfuscated, how can you detect them? There are tools designed to detect this type of obfuscated strings. If common techniques have been used, such as using a code packer (like UPX) or simple obfuscation techniques (like XOR-ing the binary data), such tools might be able to detect them. Tools like &lt;strong>FLOSS&lt;/strong> can be used to search for this kind of data.&lt;/p>
&lt;p>&lt;img src="https://ander94lakx.github.io/static/images/malware-2-strings-floss.png" alt="FLOSS strings" title="FLOSS for string analysis">&lt;/p>
&lt;p>For the sake of brevity, I haven&amp;rsquo;t included the full FLOSS output here, but the tool doesn&amp;rsquo;t detect more strings than what &lt;code>strings&lt;/code> found. At this point, it seems with this sample we haven&amp;rsquo;t had much luck. The absence of easily discoverable strings could indicate the use of obfuscation techniques. Obfuscating both data and code is common in the world of malware (and not only in the malware world—these techniques are also used to protect intellectual property, for example). In any case, in the upcoming parts, we&amp;rsquo;ll delve more into detecting obfuscations, such as analysing binary sections and entropy analysis.&lt;/p>
&lt;h1 id="metadata">Metadata&lt;/h1>
&lt;p>As this is getting quite lengthy, I&amp;rsquo;ll only cover one more basic aspect in this part: metadata analysis. Like any file, malware samples can contain interesting metadata. I say &amp;ldquo;can&amp;rdquo; because they might have been removed, overwritten by another system, or even deliberately modified to make the analysis more difficult. Even tho, it&amp;rsquo;s always worth analysing them to see if there&amp;rsquo;s any information to be found.&lt;/p>
&lt;p>There are countless applications for metadata analysis. The simplest way (and one we&amp;rsquo;ve all used at some point) is the classic method of right-clicking on the file and viewing its properties. There are also applications that allow you to do this and present the information in a more detailed and organized manner. Personally, I like to use &lt;strong>PEStudio&lt;/strong> (which, among many other features, also displays metadata) and &lt;strong>ExifTool&lt;/strong>, which is well-known for extracting metadata not only from binaries but from any kind of file (as the name suggests, it&amp;rsquo;s commonly used for analysing photo metadata).&lt;/p>
&lt;p>&lt;img src="https://ander94lakx.github.io/static/images/malware-2-metadata-remnux.png" alt="ExifTool metadata" title="Metadata with ExifTool">&lt;/p>
&lt;p>&lt;img src="https://ander94lakx.github.io/static/images/malware-2-metadata-pestudio.png" alt="PEStudio metadata" title="Metadata with PEStudio">&lt;/p>
&lt;p>In the metadata, we don&amp;rsquo;t see anything highly relevant, but we do see information about a Microsoft certificate, suggesting that the binary might be signed. You can verify this in various ways, such as using the file properties or with functions like &lt;code>Get-AuthenticodeSignature&lt;/code>.&lt;/p>
&lt;p>&lt;img src="https://ander94lakx.github.io/static/images/malware-2-certificate-properties.png" alt="Certificate Properties" title="Checking the certificate in file properties">&lt;/p>
&lt;p>If done through file properties, in the case of a valid certificate, the properties would show a new tab with information about the certificate. In this case, it doesn&amp;rsquo;t seem to have a certificate.&lt;/p>
&lt;p>&lt;img src="https://ander94lakx.github.io/static/images/malware-2-certificate-powershell.png" alt="PowerShell Certificate" title="Checking the certificate using PowerShell">&lt;/p>
&lt;p>Checking with PowerShell gives us the same result. This doesn&amp;rsquo;t necessarily mean it&amp;rsquo;s not signed; it could be because the signature is expired or the certificate used isn&amp;rsquo;t valid. Even if it&amp;rsquo;s supposedly signed with a Microsoft certificate, if these certificates are compromised (which has happened before), they&amp;rsquo;re revoked, so systems won&amp;rsquo;t consider them valid. In this case, based on the metadata information, it seems to be the case.&lt;/p>
&lt;h1 id="conclusions">Conclusions&lt;/h1>
&lt;p>Starting with malware analysis is a relatively straightforward task (don&amp;rsquo;t worry, it&amp;rsquo;s going to get more complex). Although we haven&amp;rsquo;t obtained much information so far, the fact that we haven&amp;rsquo;t found clues in the strings or the presence of a suspicious certificate already gives us hints that the file is malicious (in this case, we already knew, but when analysing unknown samples, these are interesting clues).&lt;/p>
&lt;p>However, static analysis is just getting started. In the next part, I intend to delve more into these techniques, technically analysing the binary and its sections, and going into more detail on how to detect obfuscation techniques. We&amp;rsquo;ll talk about concepts like entropy.&lt;/p>
&lt;p>But for now, stay safe and happy hacking!&lt;/p>
&lt;h1 id="more-posts">More posts&lt;/h1>
&lt;ul>
&lt;li>&lt;a href="../2022-01-26-malware-analysis-1">Malware analysis (I) - How to get started in malware analysis&lt;/a>&lt;/li>
&lt;li>Malware analysis (II) - Basic static analysis: strings and metadata&lt;/li>
&lt;li>&lt;a href="../2022-09-18-malware-analysis-3">Malware analysis (III) - Static analysis: PE32 binary format, entropy and obfuscation technique indicators&lt;/a>&lt;/li>
&lt;li>&amp;hellip;&lt;/li>
&lt;/ul></content></item><item><title>Malware analysis (I) - How to get started in malware analysis</title><link>https://ander94lakx.github.io/blog/2022-01-26-malware-analysis-1/</link><pubDate>Wed, 26 Jan 2022 00:00:00 +0000</pubDate><author>ander@protonmail.com (Ander Granado)</author><guid>https://ander94lakx.github.io/blog/2022-01-26-malware-analysis-1/</guid><description>We are living in a world full of malware. Everyone has had a problem with some kind of virus or at least knows someone who has, and everyone knows or works in a company that has been attacked using some kind of malware.
Personally, I find malware fascinating. What fascinates me about it is how effective they are. They are carefully designed to do their job and there are such sophisticated examples that it is amazing to see how someone could have thought of programming something in such a way to exploit a vulnerability or to use certain kinds of evasion mechanisms.</description><content>&lt;p>We are living in a world full of malware. Everyone has had a problem with some kind of virus or at least knows someone who has, and everyone knows or works in a company that has been attacked using some kind of malware.&lt;/p>
&lt;p>Personally, I find malware fascinating. What fascinates me about it is how effective they are. They are carefully designed to do their job and there are such sophisticated examples that it is amazing to see how someone could have thought of programming something in such a way to exploit a vulnerability or to use certain kinds of evasion mechanisms.&lt;/p>
&lt;p>Whenever I see news of a new ransomware, trojan or malware of some kind, I am curious to know how it works. I often skim through the technical reports that come out of the most publicised attacks in search of more information, and I&amp;rsquo;m often blown away by the analysts&amp;rsquo; reports. Partly because of the characteristics of the cases they analyse and the ways in which the malware works, but also because of how they are able to obtain all this information.&lt;/p>
&lt;p>&lt;img src="https://ander94lakx.github.io/static/images/wannacry.png" alt="Wannacry" title="Wannacry in action">&lt;/p>
&lt;p>These types of reports are made by malware analysts. Sometimes they are within a company&amp;rsquo;s DFIR teams, sometimes they are government or military organisations, and sometimes it is a random hacker posting on his blog about a sample he is playing with. What is clear is that they take a malware sample and analyse it. It&amp;rsquo;s a fascinating field that really catches my attention because it mixes different fields that I find very interesting. It mixes computer forensics with reverse engineering and low-level knowledge of systems. It&amp;rsquo;s like the perfect combo plate.&lt;/p>
&lt;p>Lately I&amp;rsquo;ve been learning about this area. I even did &lt;a href="https://github.com/ander94lakx/TFM_Doc">my Master Thesis&lt;/a> about it not long ago. In order to collect the interesting things I&amp;rsquo;ve been learning, I&amp;rsquo;ve decided to write a series of posts (and thus take over this blog a bit) about the process and some of the techniques that are used. I&amp;rsquo;m not an expert on the subject, but I hope to be able to help anyone who reads it and, why not, to help myself in organising my ideas.&lt;/p>
&lt;h2 id="what-is-malware-analysis">What is malware analysis?&lt;/h2>
&lt;p>Malware analysis consists of all those techniques and procedures that provide information about how malware works. The behaviour of any program, and therefore also of malware, depends on its code. If you have the original source code of a malware sample, you can simply look at it to find out how it works. No such luck in this case. The best you can have is some kind of obfuscated or compiled code, usually a binary.&lt;/p>
&lt;p>There are many types of malware. Malware can be that bit of JavaScript that has snuck onto that website with the aim of mining crypto for someone and, in return, turning your computer into a heater. Malware can also be that .exe that has been slipped in as an activator for your cracked Office. Depending on the type of malware, it is analysed in one way or another.&lt;/p>
&lt;p>In this case, I am going to focus on malware for Windows and for x86 and x86_64 architectures. If you think of malware examples, examples for x86 and x86_64 are probably the most common ones that come to mind, and they are the most common ones to find.&lt;/p>
&lt;p>In essence, analysing malware is about understanding how a program works, but without having its original source code. It is like having a black box and trying to understand how it works: you can open its guts to try to get the code out, you can launch it and see how it interacts within a system, or you can take and analyse the shape of the box to get clues about it.&lt;/p>
&lt;h2 id="what-do-you-do-to-analyse-malware">What do you do to analyse malware?&lt;/h2>
&lt;p>There are different processes and techniques for analysing malware. There are even processes and methodologies that can be followed that standardise how to do it. Even so, analysing malware consists, in essence, of extracting information about it: how it works, what mechanisms it has to evade, how and with whom it communicates, what mechanisms it uses to persist or spread, etc.&lt;/p>
&lt;p>The techniques used to extract this information are diverse, but all of them can be broadly divided into the following:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>Static analysis&lt;/strong>: this consists of analysing information about the malware without analysing its code or executing it: metadata, signatures, format and sections of the binary, etc.&lt;/p>
&lt;p>&lt;img src="https://ander94lakx.github.io/static/images/pe-bear.png" alt="PE-bear" title="Static analysis with PE-bear">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Dynamic analysis**: also called behavioural analysis, it consists of analysing the sample while it is running: files with which it interacts, system calls, network traffic, changes in the registry, etc.&lt;/p>
&lt;p>&lt;img src="https://ander94lakx.github.io/static/images/wireshark.png" alt="Wireshark" title="Capturing network traffic with Wireshark">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;em>Code analysis&lt;/em>: as the name suggests, it consists of looking at the code and there are two types:&lt;/p>
&lt;p>&lt;img src="https://ander94lakx.github.io/static/images/ghidra.png" alt="Ghidra" title="Ghidra for code analysis">&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Static code analysis&lt;/strong>: analyse the code without executing it.&lt;/li>
&lt;li>&lt;strong>Dynamic code analysis&lt;/strong>: analyse the code while it is being executed, i.e. debug it.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>As can be seen, the static part is all about analysing without executing, while the dynamic part needs the malware running. A distinction can also be made between techniques depending on whether the code is analysed or not. When analysing a sample, some types of tasks are usually performed before others. Static analysis techniques are usually easy to perform and are usually done at the beginning. Analysing the code, on the other hand, is a tedious task and is usually done later on, although this can vary depending on many things.&lt;/p>
&lt;h2 id="how-do-i-start">How do I start?&lt;/h2>
&lt;p>There is no doubt here, to analyse malware you need an isolated environment. Taking malware and putting it on your computer to start tinkering with it is a bad idea. No one wants to have malware sneaking onto their computer.&lt;/p>
&lt;p>The best way to have an isolated environment is to use a virtual machine. You can use whatever you want (VirtualBox, VMWare, &amp;hellip;). In my case I&amp;rsquo;m more of a VirtualBox user, but any of them is perfectly valid. Once you have the virtualization software, you need to create an ISO with Windows, create the virtual machine, load the image on&amp;hellip; Or maybe not?&lt;/p>
&lt;p>You can find the ISO yourself, create the machine and install Windows on it, but there is an easier way to get a Windows VM, and that is to download it directly from the internet. The best option is the VMs offered by Microsoft for developers. There are several options. You can opt for a machine that has a &lt;a href="https://developer.microsoft.com/en-us/windows/downloads/virtual-machines/">full development environment&lt;/a> (it&amp;rsquo;s bigger, but if you also want to use it to develop malware it can be fine), or the virtual machines that have &lt;a href="https://developer.microsoft.com/en-us/microsoft-edge/tools/vms/">for application testing&lt;/a> in Edge, which are lighter and, in my opinion, the best option. Of the latter, in addition to Windows 10, there are also versions for Windows 7 and Windows 8, which for older malware can be interesting. There are versions for the most famous virtualization software, such as VirtualBox or VMWare, so selecting the desired version, downloading the file and loading it into the required virtualization software is more than enough.&lt;/p>
&lt;h3 id="what-tools-do-i-need">What tools do I need?&lt;/h3>
&lt;p>With a virtual machine ready, the only thing left to do is to set it up with the necessary tools to analyse malware. There are a large number of tools for analysing malware. Some like IDA or Ghidra will sound familiar to many. At the beginning it is normal to have no idea which ones to install. The best thing to do in these cases is to make use of &lt;a href="https://github.com/mandiant/flare-vm">FLARE-VM&lt;/a>, a tool to install and keep up to date a whole set of malware scanning tools.&lt;/p>
&lt;p>&lt;img src="https://ander94lakx.github.io/static/images/flare-install.png" alt="Flare install" title="FLARE-VM installation process">&lt;/p>
&lt;p>Using this tool on our machine and leaving it for a while to install everything, we will have a machine with all the tools we need. It is the best option, above all, to test all kinds of tools and, in the future, be able to create your own lab only with the tools you like. The only disadvantage of using something like FLARE-VM is that it will increase the size of your VM considerably (about 60GB of VMs). Other than that, it&amp;rsquo;s as easy as following the &lt;a href="https://github.com/mandiant/flare-vm#windows-10-installation">installation steps&lt;/a> indicated in its repository.&lt;/p>
&lt;p>There are also other tools or distributions that come with everything ready to use. One of my favourites is &lt;a href="https://remnux.org/">Remnux&lt;/a>, a linux distribution that comes with practically everything. It even has tools to scan for Windows malware. The only problem it has for scanning Windows malware is that we won&amp;rsquo;t be able to run it on that machine. Still, highly recommended as well.&lt;/p>
&lt;p>&lt;img src="https://ander94lakx.github.io/static/images/remnux.png" alt="Remnux" title="Remnux distro">&lt;/p>
&lt;p>If you still want to install the tools manually, here are some of the tools that I like. There are many more, and this depends on preferences and needs, but for me, some of the ones I like are:&lt;/p>
&lt;ul>
&lt;li>For static analysis:
&lt;ul>
&lt;li>&lt;a href="https://www.winitor.com/">PEstudio&lt;/a> and &lt;a href="https://github.com/horsicq/Detect-It-Easy">DIE&lt;/a> for binary analysis.&lt;/li>
&lt;li>&lt;a href="https://ssdeep-project.github.io/ssdeep/index.html">ssdeep&lt;/a> and &lt;a href="https://virustotal.github.io/yara/">YARA&lt;/a> (and &lt;a href="https://github.com/Yara-Rules/rules">Yara-Rules&lt;/a>) to classify and search for similar malware.&lt;/li>
&lt;li>&lt;a href="https://github.com/mandiant/capa">capa&lt;/a> to get at-a-glance clues about the capabilities of a sample.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>For code analysis:
&lt;ul>
&lt;li>&lt;a href="https://hex-rays.com/ida-free/">IDA&lt;/a> for reversing and analysing code.&lt;/li>
&lt;li>&lt;a href="https://ghidra-sre.org/">Ghidra&lt;/a> for when you can&amp;rsquo;t decompile samples in IDA because you don&amp;rsquo;t have thousands of euros to spend.&lt;/li>
&lt;li>&lt;a href="https://x64dbg.com/">x64dbg&lt;/a> for &lt;del>cracking video games&lt;/del> debugging samples.
&lt;ul>
&lt;li>It improves a lot with &lt;a href="https://github.com/x64dbg/ScyllaHide">ScyllaHide&lt;/a> and &lt;a href="https://github.com/ThunderCls/xAnalyzer">xAnalizer&lt;/a>, two indispensable plugins.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>For behavioural analysis:
&lt;ul>
&lt;li>&lt;a href="https://processhacker.sourceforge.io/">Process Hacker&lt;/a> and the Windows &lt;a href="https://docs.microsoft.com/en-us/sysinternals/">SysInternals&lt;/a>, especially &lt;a href="https://docs.microsoft.com/en-us/sysinternals/downloads/procmon">Process Monitor&lt;/a> to be able to monitor and analyse processes and system events.
&lt;ul>
&lt;li>Process Monitor PMLs are your best ally.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="https://sourceforge.net/projects/regshot/">Regshot&lt;/a> to capture and compare registry changes.&lt;/li>
&lt;li>&lt;a href="https://www.wireshark.org/">Wireshark&lt;/a> to capture and analyse network traffic.&lt;/li>
&lt;li>&lt;a href="https://belkasoft.com/es/bat">Belkasoft Acquisition Tool&lt;/a> for memory dumps.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Others:
&lt;ul>
&lt;li>&lt;a href="https://mh-nexus.de/en/hxd/">HxD&lt;/a> as a hex editor.&lt;/li>
&lt;li>A cup of coffee on the side.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="what-next">What next?&lt;/h2>
&lt;p>With everything ready and prepared, all that remains is to find a sample to start playing with. In order not to get too overwhelmed, it is best to opt for malware samples that have already been analysed and are not too complex. Repositories such as &lt;a href="https://github.com/ytisf/theZoo">TheZoo&lt;/a> have famous malware samples. You can also search for specific ones on platforms such as &lt;a href="https://bazaar.abuse.ch/">MalwareBazaar&lt;/a>.&lt;/p>
&lt;p>Another option is to test such tools and techniques with crackmes. A crackme is the equivalent of a Hack The Box or TryHackMe machine but for reverse engineering. They are not specific to analysing malware, but the techniques used are essentially the same. Websites like &lt;a href="https://crackmes.one/">crackmes.one&lt;/a> have many crackmes of varying difficulty to practice with.&lt;/p>
&lt;p>In the next posts I will explain some of these techniques on a real malware sample to see how the different techniques are applied and how to use the different tools.&lt;/p>
&lt;p>Happy hacking!&lt;/p>
&lt;h1 id="more-posts">More posts&lt;/h1>
&lt;ul>
&lt;li>Malware analysis (I) - How to get started in malware analysis&lt;/li>
&lt;li>&lt;a href="../2022-09-11-malware-analysis-2">Malware analysis (II) - Basic static analysis: strings and metadata&lt;/a>&lt;/li>
&lt;li>&lt;a href="../2022-09-18-malware-analysis-3">Malware analysis (III) - Static analysis: PE32 binary format, entropy and obfuscation technique indicators&lt;/a>&lt;/li>
&lt;li>&amp;hellip;&lt;/li>
&lt;/ul></content></item></channel></rss>