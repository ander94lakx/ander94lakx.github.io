<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>bot on Walk on the Byte Side</title><link>https://ander94lakx.github.io/tags/bot/</link><description>Recent content in bot on Walk on the Byte Side</description><generator>Hugo -- gohugo.io</generator><language>es-es</language><managingEditor>ander@protonmail.com (Ander Granado)</managingEditor><webMaster>ander@protonmail.com (Ander Granado)</webMaster><lastBuildDate>Sat, 05 Feb 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://ander94lakx.github.io/tags/bot/index.xml" rel="self" type="application/rss+xml"/><item><title>Cómo automatizar la búsqueda de piso con un bot de Telegram</title><link>https://ander94lakx.github.io/blog/2022-02-05-bot-telegram-buscar-piso/</link><pubDate>Sat, 05 Feb 2022 00:00:00 +0000</pubDate><author>ander@protonmail.com (Ander Granado)</author><guid>https://ander94lakx.github.io/blog/2022-02-05-bot-telegram-buscar-piso/</guid><description>Estoy buscando piso y es un proceso de mierda. Hay una cantidad extrañamente escasa de pisos en mi ciudad y los que hay desaparecen rápidamente.
Me da pereza meterme todo el rato a buscar piso. En realidad no es algo tan complicado, pero a veces estoy ocupado y se me pasa mirar ese día, o estoy fuera y con el móvil es más engorroso.
Llevaba tiempo queriendo probar a hacer un bot de Telegram.</description><content>&lt;p>Estoy buscando piso y es un proceso de mierda. Hay una cantidad extrañamente escasa de pisos en mi ciudad y los que hay desaparecen rápidamente.&lt;/p>
&lt;p>Me da pereza meterme todo el rato a buscar piso. En realidad no es algo tan complicado, pero a veces estoy ocupado y se me pasa mirar ese día, o estoy fuera y con el móvil es más engorroso.&lt;/p>
&lt;p>Llevaba tiempo queriendo probar a hacer un bot de Telegram. No sabía que hacer exactamente, pero el otro día se me iluminó la bombilla. As que he creado un bot que me avisa de los pisos que hay en mi ciudad disponibles.&lt;/p>
&lt;p>&lt;img src="https://ander94lakx.github.io/static/images/scraping_telegram_python_bot.jpg" alt="Scraping Python Telegram bot" title="Scraping Telegram bot hecho en Python">&lt;/p>
&lt;p>Esto tiene dos partes. Una es la parte de web scraping. Esto es básicamente automatizar la extracción de información de sitios web. Hoy en dia casi todo se hace desde internet y buscar piso no iba a ser menos. Prácticamente todas las inmobiliarias locales y los particulares que alquilan piso cuelgan sus anuncios en alguna plataforma como Idealista o Fotocasa, así que consultando ahí puedo ir viendo que opciones nuevas van apareciendo. Es básicamente lo que estaba haciendo hasta ahora a mano y sin la constancia suficiente. Automatizándolo con web scraping me permite obtener toda esa información de un vistazo.&lt;/p>
&lt;p>La otra parte es la del bot de Telegram. Hasta hace dos días no tenia ni idea de como iba. Básicamente Telegram tiene una API cojonuda para poder hacer de todo con ella. Se pueden crear bots que se ejecuten donde sea para comunicarse directamente con los usuarios, escribir en chats o canales y realizar mil cosas. A parte, hay un &lt;a href="https://github.com/python-telegram-bot/python-telegram-bot">wrapper para Python&lt;/a> muy bueno con el que se puede utilizar la API desde Python de manera muy sencilla.&lt;/p>
&lt;h2 id="parte-1-web-scraping-con-selenium">Parte 1: web scraping con Selenium&lt;/h2>
&lt;p>No es la primera vez que hago web scraping. Hace tiempo hice un script que permitía scrapear instagram para descargar todas las imágenes de un usuario. Podéis echar un vistazo al &lt;a href="https://ander94lakx.github.io/blog/2020-04-25-instagram-bot-python/">post&lt;/a> que hice o al &lt;a href="https://github.com/ander94lakx/InstaBot">código&lt;/a> del bot (es un bot, pero no es un bot de Telegram, ojo).&lt;/p>
&lt;p>Cuando hice ese script utilicé &lt;a href="https://www.selenium.dev/">Selenium&lt;/a>, que es probablemente la mejor herramienta para web scraping que existe. No sirve solo para eso, pero permite automatizar el manejo de navegadores. Con esto lo que se puede hacer, es abrir webs, navegar por ellas, realizar acciones y extraer información de ellas programáticamente. Esto es mucho mejor que mandar directamente request con una librería para realizar peticiones, ya que al lanzar realmente una instancia de un navegador, se pueden saltar medidas que algunos sitios web tienen para bloquear mecanismos automatizados. La pega que tiene es que, al tener que abrir un navegador, no se puede ejecutar en un entorno que no tenga pantalla (aunque esto se puede solucionar fácil con librerías que simulan pantallas como &lt;a href="https://pypi.org/project/PyVirtualDisplay/">PyVirtualDisplay&lt;/a>).&lt;/p>
&lt;p>Con las herramientas listas e instaladas, solo queda usar Selenium para comenzar a hacer web scraping. En este caso lo simple es mejor. en vez de pasarle la URL base de un sitio de búsqueda de pisos, se puede sacar las URL con los parámetros para filtrar la búsqueda. En mi caso, y poniendo Idealista como ejemplo, la URL sería algo así:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>https://www.idealista.com/alquiler-viviendas/vitoria-gasteiz-alava/?ordenado-por&lt;span style="color:#f92672">=&lt;/span>precios-asc
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Como se puede ver, ya estoy filtrando por mi ciudad, a parte de que ordena por precio para que aparezcan los más baratos primero (no hay mucha pasta por aquí). Esto se podría acotar mucho más. Como la mayoría de sitios de este tipo usan los parámetros de búsqueda en la propia URL (algo muy útil para poder después guardar marcadores con ello), se puede ahorrar muchísimo trabajo de scraping solo con elegir la URL adecuada.&lt;/p>
&lt;p>&lt;img src="https://ander94lakx.github.io/static/images/idealista_web.png" alt="Resultados de Idealista" title="Resultados de la búsqueda en Idealista">&lt;/p>
&lt;p>Con eso en mente, he creado una sencilla función que permite hacer web scraping para obtener los pisos. Le he puesto una opción para filtrar por precio (aunque es algo que se puede hacer también a través de la URL). El código es el siguiente:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">scrap_idealista&lt;/span>(max_price):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> driver &lt;span style="color:#f92672">=&lt;/span> initialize_driver(IDEALISTA_URL)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> scroll_down_and_up(driver)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># Be kind and accept the cookies&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> driver&lt;span style="color:#f92672">.&lt;/span>find_element_by_id(&lt;span style="color:#e6db74">&amp;#39;didomi-notice-agree-button&amp;#39;&lt;/span>)&lt;span style="color:#f92672">.&lt;/span>click()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">except&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">pass&lt;/span> &lt;span style="color:#75715e"># No cookies button, no problem!&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># Find each flat element&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> elements &lt;span style="color:#f92672">=&lt;/span> driver&lt;span style="color:#f92672">.&lt;/span>find_element_by_xpath(&lt;span style="color:#e6db74">&amp;#39;//*[@id=&amp;#34;main-content&amp;#34;]&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> items &lt;span style="color:#f92672">=&lt;/span> elements&lt;span style="color:#f92672">.&lt;/span>find_elements_by_class_name(&lt;span style="color:#e6db74">&amp;#39;item-multimedia-container&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> flat_list &lt;span style="color:#f92672">=&lt;/span> []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> item &lt;span style="color:#f92672">in&lt;/span> items:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># Get the link for that flat&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> link &lt;span style="color:#f92672">=&lt;/span> item&lt;span style="color:#f92672">.&lt;/span>find_element_by_xpath(&lt;span style="color:#e6db74">&amp;#39;./div/a[@href]&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> link &lt;span style="color:#f92672">=&lt;/span> link&lt;span style="color:#f92672">.&lt;/span>get_attribute(&lt;span style="color:#e6db74">&amp;#39;href&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># Get the price for that flat&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result &lt;span style="color:#f92672">=&lt;/span> re&lt;span style="color:#f92672">.&lt;/span>search(&lt;span style="color:#e6db74">&amp;#39;.*&lt;/span>&lt;span style="color:#ae81ff">\\&lt;/span>&lt;span style="color:#e6db74">n(.*)€\/mes&amp;#39;&lt;/span>, item&lt;span style="color:#f92672">.&lt;/span>text)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> price_str &lt;span style="color:#f92672">=&lt;/span> result&lt;span style="color:#f92672">.&lt;/span>group(&lt;span style="color:#ae81ff">1&lt;/span>)&lt;span style="color:#f92672">.&lt;/span>replace(&lt;span style="color:#e6db74">&amp;#39;.&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> price &lt;span style="color:#f92672">=&lt;/span> int(price_str)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> price &lt;span style="color:#f92672">&amp;lt;=&lt;/span> max_price:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> flat_list&lt;span style="color:#f92672">.&lt;/span>append({
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;link&amp;#39;&lt;/span>: link,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;price&amp;#39;&lt;/span>: price,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;image&amp;#39;&lt;/span>: item&lt;span style="color:#f92672">.&lt;/span>screenshot_as_png,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;image_name&amp;#39;&lt;/span>: item&lt;span style="color:#f92672">.&lt;/span>id &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#39;.png&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> driver&lt;span style="color:#f92672">.&lt;/span>quit()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> flat_list
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Aquí se ven varias cosas, pero por lo general es bastante sencillo de entender. Antes que nada, se carga el driver de Selenium y se hace scroll por toda la página. Lo primero carga la web y permite tener todo listo para comenzar a buscar. El scroll es debido a que, en ocasiones, las webs van ofreciendo contenido a medida que el usuario va haciendo scroll, por lo que hacer un scroll rápido antes de comenzar a sacar información está muy bien.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">initialize_driver&lt;/span>(url):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> driver &lt;span style="color:#f92672">=&lt;/span> webdriver&lt;span style="color:#f92672">.&lt;/span>Chrome(executable_path&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;./chromedriver.exe&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> driver&lt;span style="color:#f92672">.&lt;/span>get(url)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sleep(&lt;span style="color:#ae81ff">2&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> driver&lt;span style="color:#f92672">.&lt;/span>set_window_position(&lt;span style="color:#ae81ff">0&lt;/span>,&lt;span style="color:#ae81ff">0&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> driver&lt;span style="color:#f92672">.&lt;/span>set_window_size(&lt;span style="color:#ae81ff">1920&lt;/span>, &lt;span style="color:#ae81ff">1080&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> driver
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Usar Selenium es muy sencillo. En este caso estoy usando el driver para Chrome, que tengo justo en mi directorio, por conveniencia. Tras ello, cargar la URL y configurar la ventana para que tenga un tamaño decente. Esto es importante, porque los elementos estarán colocados de diferente manera en función del tamaño de la ventana. El diseño responsive está muy bien, pero es uno de los peores enemigos del &lt;em>scrapper&lt;/em>, así que poner una resolución consistente es importante para obtener siempre los mismos resultados.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">scroll_down_and_up&lt;/span>(driver):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> driver&lt;span style="color:#f92672">.&lt;/span>execute_script(&lt;span style="color:#e6db74">&amp;#39;window.scrollTo(0, document.body.scrollHeight);&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sleep(&lt;span style="color:#ae81ff">2&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> driver&lt;span style="color:#f92672">.&lt;/span>execute_script(&lt;span style="color:#e6db74">&amp;#39;window.scrollTo(0, 0);&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>En lo que respecta al scroll aquí no hay nada especial. Un poco de JS y listo.&lt;/p>
&lt;p>La chicha está después. Lo primero, aceptar las cookies para poder navegar por el sitio y que no se vea nada raro. Aquí es donde se puede ver la potencia de Selenium&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>driver&lt;span style="color:#f92672">.&lt;/span>find_element_by_id(&lt;span style="color:#e6db74">&amp;#39;didomi-notice-agree-button&amp;#39;&lt;/span>)&lt;span style="color:#f92672">.&lt;/span>click()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Se explica solo. Se coge el elemento con ese ID, que en este caso es un botón, y se click. Lo siguiente es buscar los elementos con la información de los pisos. Esas tarjetitas que aparecen en lista. Como todos los elementos de una web, tienen clases o atributos que los identifican.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>elements &lt;span style="color:#f92672">=&lt;/span> driver&lt;span style="color:#f92672">.&lt;/span>find_element_by_xpath(&lt;span style="color:#e6db74">&amp;#39;//*[@id=&amp;#34;main-content&amp;#34;]&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>items &lt;span style="color:#f92672">=&lt;/span> elements&lt;span style="color:#f92672">.&lt;/span>find_elements_by_class_name(&lt;span style="color:#e6db74">&amp;#39;item-multimedia-container&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>En este caso he hecho búsquedas con XPath y a través de los nombres de las clases. Si se ve la web de idealista, se puede sacar esta información. En cada web será diferente. Lo bueno de Selenium es que te permite obtener elementos y después buscar dentro de ellos. Así, se puede ir paso a paso hasta llegar a donde se quiere.&lt;/p>
&lt;p>&lt;img src="https://ander94lakx.github.io/static/images/idealista_scraping.png" alt="Scraping en Idealista" title="Elementos a buscar con Selenium">&lt;/p>
&lt;p>Buscar a través del id y de las clases es sencillo. Buscar a través de XPath es más complicado pero muy potente. Esto se puede simplificar con una extensión como &lt;a href="https://github.com/trembacz/xpath-finder">xPath Finder&lt;/a>, que te permite obtener el XPath de cualquier elemento de una web.&lt;/p>
&lt;p>Con ello ya se tienen una lista de items, que son cada una de las tarjetitas esas. Aquí solo queda sacar la información que se quiera sacar.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> item &lt;span style="color:#f92672">in&lt;/span> items:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># Get the link for that flat&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> link &lt;span style="color:#f92672">=&lt;/span> item&lt;span style="color:#f92672">.&lt;/span>find_element_by_xpath(&lt;span style="color:#e6db74">&amp;#39;./div/a[@href]&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> link &lt;span style="color:#f92672">=&lt;/span> link&lt;span style="color:#f92672">.&lt;/span>get_attribute(&lt;span style="color:#e6db74">&amp;#39;href&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># Get the price for that flat&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result &lt;span style="color:#f92672">=&lt;/span> re&lt;span style="color:#f92672">.&lt;/span>search(&lt;span style="color:#e6db74">&amp;#39;.*&lt;/span>&lt;span style="color:#ae81ff">\\&lt;/span>&lt;span style="color:#e6db74">n(.*)€\/mes&amp;#39;&lt;/span>, item&lt;span style="color:#f92672">.&lt;/span>text)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> price_str &lt;span style="color:#f92672">=&lt;/span> result&lt;span style="color:#f92672">.&lt;/span>group(&lt;span style="color:#ae81ff">1&lt;/span>)&lt;span style="color:#f92672">.&lt;/span>replace(&lt;span style="color:#e6db74">&amp;#39;.&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> price &lt;span style="color:#f92672">=&lt;/span> int(price_str)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> price &lt;span style="color:#f92672">&amp;lt;=&lt;/span> max_price:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> flat_list&lt;span style="color:#f92672">.&lt;/span>append({
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;link&amp;#39;&lt;/span>: link,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;price&amp;#39;&lt;/span>: price,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#39;image&amp;#39;&lt;/span>: item&lt;span style="color:#f92672">.&lt;/span>screenshot_as_png
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> })
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Para esto hay muchas formas. Selenium te permite sacar el elemento como imagen, por lo que para después enviarlo de esa manera puede estar muy bien. En mi caso saco el piso como imagen (para enviar después por Telegram así), el precio (para ver que no se pase del tope establecido) y el link, para enviarlo junto a cada imagen para poder meterme en el piso que me interesa. El nombre de la imagen me permite después gestionar las imágenes para enviarlas por Telegram.&lt;/p>
&lt;p>Y esto es todo, así de sencillo. Ya solo hay que enviar esa información por Telegram.&lt;/p>
&lt;h2 id="parte-2-crear-un-bot-de-telegram">Parte 2: crear un bot de Telegram&lt;/h2>
&lt;p>Crear un bot de Telegram es tan sencillo como usar &lt;a href="https://t.me/botfather">BotFather&lt;/a>, el bot que te permite crear bots. Tras crear un bot con él, te da un token que es lo que te permite hacer lo que quieras con la API. La creación del bot es trivial, consiste en hablar con el bot.&lt;/p>
&lt;p>Una vez teniendo un token se puede hacer uso del &lt;a href="https://github.com/python-telegram-bot/python-telegram-bot">wrapper para Python&lt;/a> que he mencionado. Instalar con &lt;code>pip&lt;/code> y listo. Del wrapper he utilizado lo siguiente:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">import&lt;/span> telegram
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">from&lt;/span> telegram &lt;span style="color:#f92672">import&lt;/span> Bot, Update
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">from&lt;/span> telegram.ext &lt;span style="color:#f92672">import&lt;/span> Updater
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">from&lt;/span> telegram.ext &lt;span style="color:#f92672">import&lt;/span> CallbackContext
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">from&lt;/span> telegram.ext &lt;span style="color:#f92672">import&lt;/span> CommandHandler
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Con ello, se puede instanciar el bot con el token obtenido y crear callbacks que permitan estar a la escucha de comandos de manera sencilla.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">init&lt;/span>():
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">with&lt;/span> open(&lt;span style="color:#e6db74">&amp;#39;token.txt&amp;#39;&lt;/span>) &lt;span style="color:#66d9ef">as&lt;/span> f:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> token &lt;span style="color:#f92672">=&lt;/span> f&lt;span style="color:#f92672">.&lt;/span>read()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> updater &lt;span style="color:#f92672">=&lt;/span> Updater(token&lt;span style="color:#f92672">=&lt;/span>token, use_context&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">True&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dispatcher &lt;span style="color:#f92672">=&lt;/span> updater&lt;span style="color:#f92672">.&lt;/span>dispatcher
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logging&lt;span style="color:#f92672">.&lt;/span>basicConfig(format&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>&lt;span style="color:#e6db74">%(asctime)s&lt;/span>&lt;span style="color:#e6db74"> - &lt;/span>&lt;span style="color:#e6db74">%(name)s&lt;/span>&lt;span style="color:#e6db74"> - &lt;/span>&lt;span style="color:#e6db74">%(levelname)s&lt;/span>&lt;span style="color:#e6db74"> - &lt;/span>&lt;span style="color:#e6db74">%(message)s&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> level&lt;span style="color:#f92672">=&lt;/span>logging&lt;span style="color:#f92672">.&lt;/span>INFO)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dispatcher&lt;span style="color:#f92672">.&lt;/span>add_handler(CommandHandler(&lt;span style="color:#e6db74">&amp;#39;start&amp;#39;&lt;/span>, start))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dispatcher&lt;span style="color:#f92672">.&lt;/span>add_handler(CommandHandler(&lt;span style="color:#e6db74">&amp;#39;bilatu&amp;#39;&lt;/span>, bilatu))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dispatcher&lt;span style="color:#f92672">.&lt;/span>add_handler(CommandHandler(&lt;span style="color:#e6db74">&amp;#39;idealista&amp;#39;&lt;/span>, idealista))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dispatcher&lt;span style="color:#f92672">.&lt;/span>add_handler(CommandHandler(&lt;span style="color:#e6db74">&amp;#39;fotocasa&amp;#39;&lt;/span>, fotocasa))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> updater&lt;span style="color:#f92672">.&lt;/span>start_polling()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Esa funcion se ejecuta al arrancar el script. Cojo el token de un archivo separado y creo el bot. En el código se ve que se crean cuatro handlers. Esos son los comandos que después se pueden ejecutar con el bot. en este caso son &lt;code>/start&lt;/code>,&lt;code>/bilatu&lt;/code> (&amp;ldquo;buscar&amp;rdquo; en euskera),&lt;code>/idealista&lt;/code> ,&lt;code>/fotocasa&lt;/code>. Así se puede buscar en todos o solo en uno en específico. Las funciones llamadas con los callbacks son las siguientes:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">bilatu&lt;/span>(update: Update, context: CallbackContext):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> scrap(update, context, &lt;span style="color:#e6db74">&amp;#39;all&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">idealista&lt;/span>(update: Update, context: CallbackContext):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> scrap(update, context, &lt;span style="color:#e6db74">&amp;#39;idealista&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">fotocasa&lt;/span>(update: Update, context: CallbackContext):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> scrap(update, context, &lt;span style="color:#e6db74">&amp;#39;fotocasa&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">scrap&lt;/span>(update: Update, context: CallbackContext, site):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> send_initial_message(context, update)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> max_price &lt;span style="color:#f92672">=&lt;/span> get_max_price(context)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> flat_list &lt;span style="color:#f92672">=&lt;/span> []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> site &lt;span style="color:#f92672">in&lt;/span> { &lt;span style="color:#e6db74">&amp;#39;idealista&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;all&amp;#39;&lt;/span> }:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> flat_list&lt;span style="color:#f92672">.&lt;/span>extend(scrap_idealista(max_price))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> site &lt;span style="color:#f92672">in&lt;/span> { &lt;span style="color:#e6db74">&amp;#39;fotocasa&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;all&amp;#39;&lt;/span> }:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> flat_list&lt;span style="color:#f92672">.&lt;/span>extend(scrap_fotocasa(max_price))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> send_results(flat_list, update, context)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> send_final_message(context, update)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">send_initial_message&lt;/span>(context, update):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> context&lt;span style="color:#f92672">.&lt;/span>bot&lt;span style="color:#f92672">.&lt;/span>send_message(chat_id&lt;span style="color:#f92672">=&lt;/span>update&lt;span style="color:#f92672">.&lt;/span>effective_chat&lt;span style="color:#f92672">.&lt;/span>id, text&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;Emaidazu minutu bat!&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">send_final_message&lt;/span>(context, update):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> context&lt;span style="color:#f92672">.&lt;/span>bot&lt;span style="color:#f92672">.&lt;/span>send_message(chat_id&lt;span style="color:#f92672">=&lt;/span>update&lt;span style="color:#f92672">.&lt;/span>effective_chat&lt;span style="color:#f92672">.&lt;/span>id, text&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;Hortxe dauzkazu!&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Baásicamente se llaman a unas u otras funciones de scraping en función de el callback que se ejecuta. Los obtetos &lt;code>context&lt;/code> y &lt;code>update&lt;/code> permiten obtener la instancia del bot y toda la información relativa a los comandos que se han ejecutado (qué usuario los ha ejecutado, en que chat, grupo o canal, si ha pasado argumentos, etc.). Ahí también se puede ver los sencillo que es mandar un mensaje con un bot con la funcion &lt;code>bot.send_message()&lt;/code>.&lt;/p>
&lt;p>Lo interesante de esa parte es la función &lt;code>send_results()&lt;/code>, que coge lo generado por las funciones de scraping (la lista de pisos, cada uno con toda la información mencionada) y lo envía por Telegram.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">send_results&lt;/span>(flat_list: list, update: Update, context: CallbackContext):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> flat &lt;span style="color:#f92672">in&lt;/span> flat_list:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> context&lt;span style="color:#f92672">.&lt;/span>bot&lt;span style="color:#f92672">.&lt;/span>send_photo(chat_id&lt;span style="color:#f92672">=&lt;/span>update&lt;span style="color:#f92672">.&lt;/span>effective_chat&lt;span style="color:#f92672">.&lt;/span>id, caption&lt;span style="color:#f92672">=&lt;/span>flat[&lt;span style="color:#e6db74">&amp;#39;link&amp;#39;&lt;/span>], photo&lt;span style="color:#f92672">=&lt;/span>flat[&lt;span style="color:#e6db74">&amp;#39;image&amp;#39;&lt;/span>])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sleep(&lt;span style="color:#ae81ff">1&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Esto tambien bastante sencillo. Para enviar un mensaje basta con indicar el id del chat (que es algo que se recibe en los callbacks, apra saber desde donde se ha llamdo al comando) y lo que se quiera mandar. Antes se ha visto como se mandaba un mensaje con &lt;code>bot.send_message()&lt;/code>, pasando el chat y el texto. En este caso se envia la foto de cada piso con &lt;code>bot.send_photo()&lt;/code>, indicando en &lt;code>photo&lt;/code> la imagen recogida y en &lt;code>caption&lt;/code> el link.&lt;/p>
&lt;p>Con todo ello, es tan sencillo como lanzarlo y comenzar a buscar piso.&lt;/p>
&lt;p>&lt;img src="https://ander94lakx.github.io/static/images/telegram_bot.png" alt="Bot de Telegram" title="Bot de Telegram buscando piso">&lt;/p>
&lt;p>Tal y como queda me parece bastante elegante. Cogiendo el elemento entero como imagen se puede ver toda la información de un vistazo y poniendo el enlace se puede acceder al anuncio para obtener más información o directamente contactar con el anunciante. Otra opción podría haber sido coger el texto y haber creado una lista con los pisos y los enlaces, pero la primera forma me parece de las más elegantes y, sin duda, la más sencilla de todas.&lt;/p>
&lt;h2 id="parte-3-crear-un-canal-de-telegram-para-informar-de-los-pisos">Parte 3: crear un canal de Telegram para informar de los pisos&lt;/h2>
&lt;p>Sí, con esto no tengo suficiente. Escribir un comando al bot es demasiado trabajo. Por ello, a parte de tener el bot así, he añadido un metodo para que el bot, cada cierto tiempo, escriba en un canal las ofertas que hay. Esto es basicamente lo msimo que hace por ejemplo el &lt;a href="https://t.me/getmanfred">bot de Manfred&lt;/a> con las ofertas de trabajo, pero con mayor frecuencia. Además, me gusta como en ese bot no va dejando los mensajes de días anteriores, sino que solo está el último mensaje. Así evita que se llene el canal de mierda y deja que haya solo lo que tiene que haber. Por ello, yo lo he hecho igual.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">update_channel&lt;/span>():
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># Get channel and bot info&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">with&lt;/span> open(&lt;span style="color:#e6db74">&amp;#39;token.txt&amp;#39;&lt;/span>) &lt;span style="color:#66d9ef">as&lt;/span> f:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> token &lt;span style="color:#f92672">=&lt;/span> f&lt;span style="color:#f92672">.&lt;/span>read()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">with&lt;/span> open(&lt;span style="color:#e6db74">&amp;#39;channel_id.txt&amp;#39;&lt;/span>) &lt;span style="color:#66d9ef">as&lt;/span> f:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> channel_id &lt;span style="color:#f92672">=&lt;/span> f&lt;span style="color:#f92672">.&lt;/span>read()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bot &lt;span style="color:#f92672">=&lt;/span> telegram&lt;span style="color:#f92672">.&lt;/span>Bot(token&lt;span style="color:#f92672">=&lt;/span>token)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># Remove previously sended messages&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stacked_messages &lt;span style="color:#f92672">=&lt;/span> []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">with&lt;/span> open(&lt;span style="color:#e6db74">&amp;#39;sent_messages.txt&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;r&amp;#39;&lt;/span>) &lt;span style="color:#66d9ef">as&lt;/span> f:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> line &lt;span style="color:#f92672">in&lt;/span> f&lt;span style="color:#f92672">.&lt;/span>readlines():
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stacked_messages&lt;span style="color:#f92672">.&lt;/span>append(int(line))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> stacked_messages:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> bot&lt;span style="color:#f92672">.&lt;/span>delete_message(chat_id&lt;span style="color:#f92672">=&lt;/span>channel_id, message_id&lt;span style="color:#f92672">=&lt;/span>stacked_messages&lt;span style="color:#f92672">.&lt;/span>pop())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># Scrap all with the defaul top price&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> flat_list &lt;span style="color:#f92672">=&lt;/span> []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> flat_list&lt;span style="color:#f92672">.&lt;/span>extend(scrap_idealista(top_price))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> flat_list&lt;span style="color:#f92672">.&lt;/span>extend(scrap_fotocasa(top_price))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># Send the messages with the info&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># Saves the message_id of the messages to be able to delete them on the next one&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stacked_messages&lt;span style="color:#f92672">.&lt;/span>append(bot&lt;span style="color:#f92672">.&lt;/span>send_message(chat_id&lt;span style="color:#f92672">=&lt;/span>channel_id, text&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;Kaixo! Hamen dauzkazu oraintxe bertan dauden pisuak:&amp;#39;&lt;/span>)&lt;span style="color:#f92672">.&lt;/span>message_id)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> flat &lt;span style="color:#f92672">in&lt;/span> flat_list:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stacked_messages&lt;span style="color:#f92672">.&lt;/span>append(bot&lt;span style="color:#f92672">.&lt;/span>send_photo(chat_id&lt;span style="color:#f92672">=&lt;/span>channel_id, caption&lt;span style="color:#f92672">=&lt;/span>flat[&lt;span style="color:#e6db74">&amp;#39;link&amp;#39;&lt;/span>], photo&lt;span style="color:#f92672">=&lt;/span>flat[&lt;span style="color:#e6db74">&amp;#39;image&amp;#39;&lt;/span>])&lt;span style="color:#f92672">.&lt;/span>message_id)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sleep(&lt;span style="color:#ae81ff">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stacked_messages&lt;span style="color:#f92672">.&lt;/span>append(bot&lt;span style="color:#f92672">.&lt;/span>send_message(chat_id&lt;span style="color:#f92672">=&lt;/span>channel_id, text&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;Hortxe dauzkazu!&amp;#39;&lt;/span>)&lt;span style="color:#f92672">.&lt;/span>message_id)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">with&lt;/span> open(&lt;span style="color:#e6db74">&amp;#39;sent_messages.txt&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;w&amp;#39;&lt;/span>) &lt;span style="color:#66d9ef">as&lt;/span> f:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> message &lt;span style="color:#f92672">in&lt;/span> stacked_messages:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> f&lt;span style="color:#f92672">.&lt;/span>write(str(message) &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#39;&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Lo sé, esto no es lo más limpio que has visto en tu vida. Es basicamente más de lo mismo pero gestionando los mensajes que se han enviado. Cada mensaje enviado tiene un &lt;code>message_id&lt;/code>, que es lo que permite despues poder elimiarlos. Esta función basicamente elimina lo que se haya escrito antes en el canal, realiza el scraping, manda la información y guarda los &lt;code>message_id&lt;/code> para poder borrar los mensajes la próxima vez. Guarda esos id en un fichero para que, si peta el bot, no se pierdan y se puedan borrar al iniciarlo de nuevo, así no queda basura en el canal.&lt;/p>
&lt;p>En este caso, hace falta crear una instancia de &lt;code>Bot&lt;/code> ya que no se recibe de ningun lado. Ademas de esto, es necesario tener el id del chat o canal en el que se quiera escribir. Hay muchos bots que permiten sacar esos id.&lt;/p>
&lt;p>La idea tener el script en ejecucion 24/7 y con ello el bot siempre listo. Por un lado, con los handlers escuchando, lo que se hace con &lt;code>updater.start_polling()&lt;/code> visto antes. Por otro lado, hay que tener alguna manera para ejecutar la función &lt;code>update_channel()&lt;/code> cada cierto tiempo. Para ello se puede usar &lt;code>schedule&lt;/code>, una librería que permite programar tareas de manera sencilla. Para instalar, usar &lt;code>pip&lt;/code> y listo.&lt;/p>
&lt;p>Para usarla para ejecutar &lt;code>update_channel()&lt;/code> cada cierto tiempo, basta con añadir al final de la función &lt;code>init()&lt;/code> lo siguiente:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>schedule&lt;span style="color:#f92672">.&lt;/span>every()&lt;span style="color:#f92672">.&lt;/span>hour&lt;span style="color:#f92672">.&lt;/span>at(&lt;span style="color:#e6db74">&amp;#34;:00&amp;#34;&lt;/span>)&lt;span style="color:#f92672">.&lt;/span>do(update_channel)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">while&lt;/span> &lt;span style="color:#66d9ef">True&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> schedule&lt;span style="color:#f92672">.&lt;/span>run_pending()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sleep(&lt;span style="color:#ae81ff">1&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Como se ve, es muy sencillo de usar y el código se explica solo. No hay que asustarse por el &lt;code>while True&lt;/code>. El polling de los callbacks se ejecuta en otros hilos, por lo que esto no interfiere. Esto hace que se quede indefinidamente comprobando si tiene que lanzar alguna tarea.&lt;/p>
&lt;p>Con todo esto, ya solo queda dejarlo en algun lugar ejecutándose. Este tipo de cosas son perfectas para una Raspberry Pi o algo del estilo. También se puede meter en un VPS o en donde sea. Lo único que hay que tener en cuenta es que, o tenga pantalla, o se use alguna libreria como la mencionada para emularla. Además de que tiene que tener el navegador que se vaya a usar instalado.&lt;/p>
&lt;p>También se pueden añádir más sitios a los que hacer scraping, es facilmente escalable. En mi caso uso Idealista y Fotocasa, pero basta con añadir más funciones de scraping. Obviamente, cómo coger la informacion varía de sitio a sitio.&lt;/p>
&lt;h2 id="conclusiones">Conclusiones&lt;/h2>
&lt;p>Crear un bot de este tipo es una tarea sencilla, como se puede ver. Aquí la dificultad está en encontrar un piso decente que no cueste un ojo de la cara. Eso si que es difícil de verdad.&lt;/p>
&lt;p>Hacer un bot para obtener información actualizada de una puede ser muy util. Usar web scraping en vez de usar APIs tiene sus ventajas. Lo primero es que la mayoria de webs no tienen APIs, por lo que en esos caso no queda otra. En los casos en las que sí tienen, pueden estar limitadas. Lo bueno del web scraping es que te permite coger &lt;strong>lo que tú quieras y como tú quieras&lt;/strong>. Y que nadie os engañe; aqui, mientras no tires la web o extraigas datos de manera masiva, no hay delito.&lt;/p>
&lt;p>Espero haberme explicado bien y que si lees esto te pique la curiosidad para trastear con estos temas. Yo, por mi parte no voy a parar :)&lt;/p>
&lt;p>Por último, dejo aquí el &lt;a href="https://github.com/ander94lakx/pisu-bot">repo de GitHub&lt;/a> con el código completo. Como siempre, libre para que hagáis lo que queráis.&lt;/p>
&lt;p>Y recordad: &lt;em>&lt;strong>Scraping is not a crime!&lt;/strong>&lt;/em>&lt;/p></content></item><item><title>Cómo descargarse las imágenes de un perfil de Instagram con Python y web scrapping</title><link>https://ander94lakx.github.io/blog/2020-04-25-instagram-bot-python/</link><pubDate>Sat, 25 Apr 2020 00:00:00 +0000</pubDate><author>ander@protonmail.com (Ander Granado)</author><guid>https://ander94lakx.github.io/blog/2020-04-25-instagram-bot-python/</guid><description>Instagram es la red del postureo. Es probablemente la red social que más uso. Soy demasiado joven como para usar Facebook activamente y demasiado viejo siquiera para plantearme crearme TikTok (si veis que ocurre, os doy permiso para acabar con mi existencia). También uso twitter, pero más como proveedor de &amp;ldquo;noticias&amp;rdquo;, pero no publico nada en esa red social.
Por lo tanto, todas mis publicaciones suelen ir a Instagram. A lo largo de los años me he dado cuenta de que se ha convertido en una especie de diario de hitos personales.</description><content>&lt;p>Instagram es la red del postureo. Es probablemente la red social que más uso. Soy demasiado joven como para usar Facebook activamente y demasiado viejo siquiera para plantearme crearme TikTok (si veis que ocurre, os doy permiso para acabar con mi existencia). También uso twitter, pero más como proveedor de &amp;ldquo;noticias&amp;rdquo;, pero no publico nada en esa red social.&lt;/p>
&lt;p>Por lo tanto, todas mis publicaciones suelen ir a Instagram. A lo largo de los años me he dado cuenta de que se ha convertido en una especie de diario de hitos personales. Por encima de las fotos de mis viajes se pueden ver y observar fotos de cuando me saqué la carrera, de cuando vivía en Madrid y estaba en un estudio programando un videojuego o de buenos momentos con amigos. Aunque la calidad de las imágenes puede no ser la mejor, me gusta meterme de vez en cuando ahí y ver todos esos viajes y momentos.&lt;/p>
&lt;p>Aun así, soy informático y se que la única manera de que tu información pueda estar segura es tener tú mismo una copia. Por ello llevaba tiempo planteándome realizar algún script que me permitiera bajarme todas las fotos de mi perfil. También podia usar esto para refrescar un poco Python y practicar algo de Web Scrapping.&lt;/p>
&lt;h1 id="web-scrapping-con-selenium">Web Scrapping con Selenium&lt;/h1>
&lt;p>Hace tiempo hubo un intento fallido por mi parte, principalmente porque intente descargar, &lt;em>parsear&lt;/em> y buscar las páginas a mano. El problema es que una página no consiste únicamente en un HTML, y hacerlo a mano implica ir &amp;ldquo;tirando del hilo&amp;rdquo; hasta obtener todos los recursos que componen una página. Por lo tanto lo deje aparcado. Eso hasta el otro día, en el que de pura casualidad encontré un &lt;a href="https://www.youtube.com/watch?v=d2GBO_QjRlo">video&lt;/a> en el que alguien programaba un bot para Instagram para ver la gente que le había dado unfollow. El objetivo que tenía me daba igual, pero quería ver como lo hacía.&lt;/p>
&lt;p>Al ver como lo hacia vi que utilizaba una librería llamada &lt;a href="https://www.selenium.dev/">Selenium&lt;/a>, que es una herramienta que permite automatizar un navegador. Es básicamente el santo grial del Web Scrapping, permite ahorrarte todo el engorro de realizar las peticiones, filtrar las páginas, buscar etiquetas, etc. Así que me baje el WebDriver para Firefox (es el puente que une la librería con el navegador), instalé la librería para Python y basándome en el video comencé a programar.&lt;/p>
&lt;h1 id="loguearse-en-instagram">Loguearse en Instagram&lt;/h1>
&lt;p>&lt;img src="https://ander94lakx.github.io/static/images/ig-login.png" alt="Web de login de instagram">&lt;/p>
&lt;p>Lo primero que hay que hacer es hacer &lt;em>log in&lt;/em> en la página. Para ello, lo que hay que hacer es lo siguiente&lt;/p>
&lt;ol>
&lt;li>Obtener la web. Al no habernos logueado, la web que aparecerá será la de login&lt;/li>
&lt;li>Obtener los campos de usuario y contraseña y llenarlos&lt;/li>
&lt;li>Pulsar el botón de &lt;em>Log in&lt;/em>&lt;/li>
&lt;/ol>
&lt;p>Todo ello se hace en Python de la siguiente manera:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">InstaBot&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">def&lt;/span> __init__(self, username, pw):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#f92672">.&lt;/span>driver &lt;span style="color:#f92672">=&lt;/span> webdriver&lt;span style="color:#f92672">.&lt;/span>Firefox(executable_path&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;./geckodriver.exe&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#f92672">.&lt;/span>username &lt;span style="color:#f92672">=&lt;/span> username
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#f92672">.&lt;/span>driver&lt;span style="color:#f92672">.&lt;/span>get(&lt;span style="color:#e6db74">&amp;#34;https://instagram.com&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sleep(&lt;span style="color:#ae81ff">2&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#f92672">.&lt;/span>driver&lt;span style="color:#f92672">.&lt;/span>find_element_by_xpath(&lt;span style="color:#e6db74">&amp;#34;//input[@name=&lt;/span>&lt;span style="color:#ae81ff">\&amp;#34;&lt;/span>&lt;span style="color:#e6db74">username&lt;/span>&lt;span style="color:#ae81ff">\&amp;#34;&lt;/span>&lt;span style="color:#e6db74">]&amp;#34;&lt;/span>)\
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">.&lt;/span>send_keys(username)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#f92672">.&lt;/span>driver&lt;span style="color:#f92672">.&lt;/span>find_element_by_xpath(&lt;span style="color:#e6db74">&amp;#34;//input[@name=&lt;/span>&lt;span style="color:#ae81ff">\&amp;#34;&lt;/span>&lt;span style="color:#e6db74">password&lt;/span>&lt;span style="color:#ae81ff">\&amp;#34;&lt;/span>&lt;span style="color:#e6db74">]&amp;#34;&lt;/span>)\
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">.&lt;/span>send_keys(pw)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#f92672">.&lt;/span>driver&lt;span style="color:#f92672">.&lt;/span>find_element_by_xpath(&lt;span style="color:#e6db74">&amp;#39;//button[@type=&amp;#34;submit&amp;#34;]&amp;#39;&lt;/span>)\
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">.&lt;/span>click()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sleep(&lt;span style="color:#ae81ff">4&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#f92672">.&lt;/span>driver&lt;span style="color:#f92672">.&lt;/span>find_element_by_xpath(&lt;span style="color:#e6db74">&amp;#34;//button[contains(text(), &amp;#39;Ahora no&amp;#39;)]&amp;#34;&lt;/span>)\
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">.&lt;/span>click()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sleep(&lt;span style="color:#ae81ff">2&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Como se puede ver, he metido el código en el constructor de una clase, que es la clase donde voy a implementar todo. Está en el constructor porque, independientemente de lo que se quiera hacer, es necesario realizar ese login. Los &lt;code>sleep()&lt;/code> son necesarios ya que hay que dejar tiempo para que cargue la página.&lt;/p>
&lt;p>Si se ejecuta eso, se ve que en realidad es el mismo proceso que realizaría cualquiera para meterse en Instagram, solo que automatizado. Incluso se puede ver en directo en el navegador aislado que abre el WebDriver. No voy a indagar en cada función, ya que creo que los nombres son muy explicativos y es fácil comprender que esta haciendo cada una.&lt;/p>
&lt;h1 id="obtener-todos-los-posts">Obtener todos los posts&lt;/h1>
&lt;p>&lt;img src="https://ander94lakx.github.io/static/images/ig-posts.png" alt="Posts de Instagram">&lt;/p>
&lt;p>Una vez hecho eso, mi idea era ir a la página del perfil, coger cada enlace a cada post y de cada uno coger la URL donde se encuentra la imagen. Este es un proceso que ya he hecho a mano, por lo tanto se que las imágenes de Instagram se pueden coger si vas inspeccionando el HTML en búsqueda de la URL de la imagen, la URL de un post suele ser algo así, que esta en la etiqueta &lt;code>&amp;lt;img&amp;gt;&lt;/code> anidada por varios &lt;code>&amp;lt;div&amp;gt;&lt;/code>:&lt;/p>
&lt;p>&lt;img src="https://ander94lakx.github.io/static/images/g-image-post-url.png" alt="URL de la imagen de un post de Instagram">&lt;/p>
&lt;p>Pero antes de llegar a eso, es necesario coger los enlaces a todos los post, para poder buscar el enlace de la imagen para cada uno de ellos. Los enlaces de un post de Instagram tienen el formato &lt;code>https://www.instagram.com/p/B--N-oBKdPL/&lt;/code>. Para cogerlos, una vez llegados la página del perfil, hay que ir bajando abajo e ir buscando estos enlaces.&lt;/p>
&lt;p>Mi idea inicial era hacer scroll hasta abajo del todo y después buscar todos los enlaces. El problema es que la página de perfil solo mantiene un número de post cargados en el grid y, a medida que se va bajando y se va cargando nuevos, los anteriores desaparecen. En mi experiencia suele mantener cargados en torno a 30. Por lo tanto, lo que habría que hacer es hacer scroll e ir cogiendo los enlaces. Para ello he creado la función &lt;code>get_pictures_links()&lt;/code>, que contiene lo siguiente:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">get_pictures_links&lt;/span>(self):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#f92672">.&lt;/span>driver&lt;span style="color:#f92672">.&lt;/span>find_element_by_xpath(&lt;span style="color:#e6db74">&amp;#34;//a[contains(@href,&amp;#39;/&lt;/span>&lt;span style="color:#e6db74">{}&lt;/span>&lt;span style="color:#e6db74">&amp;#39;)]&amp;#34;&lt;/span>&lt;span style="color:#f92672">.&lt;/span>format(self&lt;span style="color:#f92672">.&lt;/span>username))\
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">.&lt;/span>click()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sleep(&lt;span style="color:#ae81ff">2&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> links &lt;span style="color:#f92672">=&lt;/span> []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> last_height &lt;span style="color:#f92672">=&lt;/span> self&lt;span style="color:#f92672">.&lt;/span>driver&lt;span style="color:#f92672">.&lt;/span>execute_script(&lt;span style="color:#e6db74">&amp;#34;return document.body.scrollHeight&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> &lt;span style="color:#66d9ef">True&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#f92672">.&lt;/span>driver&lt;span style="color:#f92672">.&lt;/span>execute_script(&lt;span style="color:#e6db74">&amp;#34;window.scrollTo(0, document.body.scrollHeight);&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sleep(&lt;span style="color:#ae81ff">2&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> links_elements &lt;span style="color:#f92672">=&lt;/span> self&lt;span style="color:#f92672">.&lt;/span>driver&lt;span style="color:#f92672">.&lt;/span>find_elements_by_xpath(&lt;span style="color:#e6db74">&amp;#39;//a[contains(@href,&amp;#34;p/&amp;#34;)]&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> elem &lt;span style="color:#f92672">in&lt;/span> links_elements:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> links&lt;span style="color:#f92672">.&lt;/span>append(elem&lt;span style="color:#f92672">.&lt;/span>get_attribute(&lt;span style="color:#e6db74">&amp;#39;href&amp;#39;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> new_height &lt;span style="color:#f92672">=&lt;/span> self&lt;span style="color:#f92672">.&lt;/span>driver&lt;span style="color:#f92672">.&lt;/span>execute_script(&lt;span style="color:#e6db74">&amp;#34;return document.body.scrollHeight&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> new_height &lt;span style="color:#f92672">==&lt;/span> last_height:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> last_height &lt;span style="color:#f92672">=&lt;/span> new_height
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> links &lt;span style="color:#f92672">=&lt;/span> list(set(links))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> links
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Hay varias cosas a resaltar en el fragmento anterior:&lt;/p>
&lt;ul>
&lt;li>El scroll se hace mediante JavaScript. Para ejecutar código JavaScript en la web se usa la función &lt;code>execute_script()&lt;/code>&lt;/li>
&lt;li>El contador de altura sirve para saber cuando hay que parar de bajar. Si al bajar sigue en la misma altura del final se para&lt;/li>
&lt;li>Para buscar los enlaces a los post hay que buscar las etiquetas &lt;code>&amp;lt;a&amp;gt;&lt;/code> correspondientes. En este caso se busca una etiqueta de enlace que contenga &lt;code>/p&lt;/code> en el atributo &lt;code>href&lt;/code>.
&lt;ul>
&lt;li>Una vez obtenida la etiqueta o, como en este caso, la lista de etiquetas que cumplen ese criterio, se obtienen los atributos en sí, que son las URL que queremos. Estas se guardan en la lista.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Por como funciona el grid, lo normal es acabar cogiendo valores repetidos, ya que las etiquetas se van descargando al cabo del tiempo, pero se mantienen durante varios scrolls. Por lo tanto, al final del todo, se hace el &lt;code>list(set(links))&lt;/code> para eliminar duplicados (se pasa a un set, que no puede contener repetidos, y después a una lista para dejarlo como antes). Hacer eso deja los elementos desordenados, pero en este caso no importa. De las soluciones que he encontrado en &lt;a href="https://stackoverflow.com/a/7961393">StackOverflow&lt;/a>, esa me parecía la más limpia y apta para este caso.&lt;/li>
&lt;/ul>
&lt;h1 id="obtener-los-_permalinks_-a-las-imágenes">Obtener los &lt;em>permalinks&lt;/em> a las imágenes&lt;/h1>
&lt;p>Con todos los posts, no queda más que ir uno a uno, para abrirlos y buscar las imágenes que contienen. Para ello, he creado la función &lt;code>get_picture()&lt;/code>, a la que le voy pasando cada uno de los links que previamente he obtenido y busco la imagen para descargarla.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">get_picture&lt;/span>(self, link):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#f92672">.&lt;/span>driver&lt;span style="color:#f92672">.&lt;/span>get(link)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sleep(&lt;span style="color:#ae81ff">2&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> img_element &lt;span style="color:#f92672">=&lt;/span> self&lt;span style="color:#f92672">.&lt;/span>driver&lt;span style="color:#f92672">.&lt;/span>find_element_by_xpath(&lt;span style="color:#e6db74">&amp;#39;//img[contains(@class,&amp;#34;FFVAD&amp;#34;)]&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> url &lt;span style="color:#f92672">=&lt;/span> img_element&lt;span style="color:#f92672">.&lt;/span>get_attribute(&lt;span style="color:#e6db74">&amp;#39;src&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> time_element &lt;span style="color:#f92672">=&lt;/span> self&lt;span style="color:#f92672">.&lt;/span>driver&lt;span style="color:#f92672">.&lt;/span>find_elements_by_tag_name(&lt;span style="color:#e6db74">&amp;#39;time&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> timestamp &lt;span style="color:#f92672">=&lt;/span> time_element[&lt;span style="color:#ae81ff">0&lt;/span>]&lt;span style="color:#f92672">.&lt;/span>get_attribute(&lt;span style="color:#e6db74">&amp;#39;datetime&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> url &lt;span style="color:#f92672">is&lt;/span> &lt;span style="color:#f92672">not&lt;/span> &lt;span style="color:#66d9ef">None&lt;/span> &lt;span style="color:#f92672">and&lt;/span> timestamp &lt;span style="color:#f92672">is&lt;/span> &lt;span style="color:#f92672">not&lt;/span> &lt;span style="color:#66d9ef">None&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> timestamp &lt;span style="color:#f92672">=&lt;/span> timestamp&lt;span style="color:#f92672">.&lt;/span>replace(&lt;span style="color:#e6db74">&amp;#39;:&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;-&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> timestamp &lt;span style="color:#f92672">=&lt;/span> timestamp&lt;span style="color:#f92672">.&lt;/span>replace(&lt;span style="color:#e6db74">&amp;#39;.&amp;#39;&lt;/span>, &lt;span style="color:#e6db74">&amp;#39;-&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print(url)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> urllib&lt;span style="color:#f92672">.&lt;/span>request&lt;span style="color:#f92672">.&lt;/span>urlretrieve(url, timestamp &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#e6db74">&amp;#39;.jpg&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">except&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">pass&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Obviando que no trato la excepción (y debería), aquí es donde realmente ocurre la magia y donde hay más problemas. De momento la forma más sencilla que he encontrado para obtener la etiqueta que contiene la imagen real, es buscarla mediante su clase. Los nombres de todas las clases que se usan en el HTML de la web de Instagram están ofuscados. Pero, basándome en las pruebas que he estado realizando, estos no cambian en el tiempo, por lo tanto usando ese nombre de clase. Una vez sabiendo cómo hacerlo, es muy fácil encontrar con Seleniun la etiqueta y obtener la URL.&lt;/p>
&lt;p>Además, para poder guardar las imágenes también obtengo el timestamp de cuando se publicó el post. A partir de ahi, no hace falta mas que descargar la imagen con &lt;code>urllib&lt;/code>.&lt;/p>
&lt;h1 id="conclusión">Conclusión&lt;/h1>
&lt;p>El bot tiene muchas partes con margen de mejora. Hasta ahora no he hablado de los post que contienen un video ni de los post que contienen varias imágenes. Iré mejorándolo con el tiempo, pero creo que tal y como esta es una buena herramienta para entender como hacer Web Scrapping a nivel básico. Voy a dejar el código en un &lt;a href="https://github.com/ander94lakx/InstaBot">repositorio de GitHub&lt;/a>, donde se irán pudiendo ver dichas mejoras.&lt;/p>
&lt;h1 id="y-la-api-de-instagram">¿Y la API de Instagram?&lt;/h1>
&lt;p>En este punto quizás alguien se plantee por que hacer todo esto y no usar directamente la API de Instagram. Por un lado, se que hay una nueva API, pero no la conozco. Mi objetivo es intentar hacer lo mismo que hace esta herramienta pero con dicha API. La que conozco es API anterior, la cual me parece limitada y pronto quedará en desuso.&lt;/p>
&lt;p>Aun así, el objetivo de este bot es no depender de si Instagram te va a permitir obtener dichas imágenes o no. Al fin y al cabo, una vez habiéndote logueado en la aplicación, técnicamente se pueden coger todas las imágenes que quieras, por lo que deberías ser capaz de hacerlo también de manera programática.&lt;/p>
&lt;p>Al final, no consiste en si Instagram te va a dejar o no, sino en: ¿si puedes, por qué no hacerlo?&lt;/p></content></item></channel></rss>