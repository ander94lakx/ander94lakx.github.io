<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>bluetoothctl on Walk on the Byte Side</title><link>https://ander94lakx.github.io/tags/bluetoothctl/</link><description>Recent content in bluetoothctl on Walk on the Byte Side</description><generator>Hugo -- gohugo.io</generator><language>es-es</language><managingEditor>ander@protonmail.com (Ander Granado)</managingEditor><webMaster>ander@protonmail.com (Ander Granado)</webMaster><lastBuildDate>Thu, 16 Feb 2023 16:00:00 +0100</lastBuildDate><atom:link href="https://ander94lakx.github.io/tags/bluetoothctl/index.xml" rel="self" type="application/rss+xml"/><item><title>Cómo monitorizar dispositivos bluetooth cercanos con un solo comando</title><link>https://ander94lakx.github.io/blog/2023-02-15-bluetooth-monitoring-command-linux/</link><pubDate>Thu, 16 Feb 2023 16:00:00 +0100</pubDate><author>ander@protonmail.com (Ander Granado)</author><guid>https://ander94lakx.github.io/blog/2023-02-15-bluetooth-monitoring-command-linux/</guid><description>Aspaldiko! Llevaba mucho tiempo sin pasarme por aquí, han sido unos meses con bastante lío (trabajo, mudanza, navidades,&amp;hellip; mil cosas), pero ya era hora de que retomara un poco la actividad en el blog. Aunque todavía tengo que retomar la serie sobre análisis de malware, he decidido que, mientras tanto, voy a ir poniendo algún post sobre alguna cosa que he ido trasteando últimamente, como este, sobre monitorizar dispositivos bluetooth.</description><content>&lt;p>Aspaldiko! Llevaba mucho tiempo sin pasarme por aquí, han sido unos meses con bastante lío (trabajo, mudanza, navidades,&amp;hellip; mil cosas), pero ya era hora de que retomara un poco la actividad en el blog. Aunque todavía tengo que retomar la serie sobre análisis de malware, he decidido que, mientras tanto, voy a ir poniendo algún post sobre alguna cosa que he ido trasteando últimamente, como este, sobre monitorizar dispositivos bluetooth.&lt;/p>
&lt;p>Me encanta Linux. Con la terminal te sientes poderoso. No es que sea un experto en ella, pero cuando te sabes manejar un poco se pueden realizar muchas cosas.&lt;/p>
&lt;p>El otro día quise hacer un pequeño script para monitorizar los dispositivos bluetooth que tengo a mi alrededor. Lo veía como un ejercicio interesante para obtener datos, como saber cuántos dispositivos tengo cerca, ver que tipo de dispositivos son, cuantos dispositivos vienen y van, y ver que se puede hacer con esa información.&lt;/p>
&lt;p>Mi instinto al querer hacer algo del estilo es hacer un script (malditos programadores, siempre &lt;a href="https://www.npmjs.com/package/is-odd">reinventando la rueda&lt;/a>). El lenguaje de scripting con el que más comodo me siento es Python, por lo que pensé en usarlo para hacer esto. Después pensé que, en realidad, lo que quería hacer no era más que usar la salida de un comando (&lt;code>bluetoothctl&lt;/code>), hacer cuatro cosas y volcarlo a un archivo.&lt;/p>
&lt;p>Entoces se me ocurrió que, para eso, lo que debería hacer es más un shell script que usar algo tan &lt;em>overkill&lt;/em> como Python. Así, lo podía usar siempre, menos dependencias, etc.&lt;/p>
&lt;p>Dándole una vuelta más, me planteé si realmente era necesario un script para esto. Lo mismo entre pipes, greps y transformaciones podía hacer un &lt;em>oneline&lt;/em> que pudiera meter en un alias y listo. A veces, cuando busco como obtener cierta info o como hacer ciertas tareas en Linux, los resultados de sitios como &lt;em>Super User&lt;/em> muestran a gente poniendo locuras de comandos para poder hacer todo tipo de virguerías, por lo que pensé que yo podía hacer lo mismo, o al menos intentarlo. Por ello, hoy vengo a explicar cómo montar un comando para monitorizar los dispositivos bluetooth que tengo alrededor.&lt;/p>
&lt;p>Lo primero es lo primero. La herramienta para trabajar con bluetooth que he usado es &lt;code>bluetoothctl&lt;/code>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>bluetoothctl
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://ander94lakx.github.io/static/images/bt-oneline/bt-oneline-1.png" alt="Bluetooth oneliner">&lt;/p>
&lt;p>Si se ejecuta, se ve que funciona en modo interactivo. Para escanear dispositivos simplemente hace falta usar el subcomando &lt;code>scan on&lt;/code> y, con ello, se pone a detectar dispositivos que aparecen, desaparecen o cambian propiedades.&lt;/p>
&lt;p>&lt;img src="https://ander94lakx.github.io/static/images/bt-oneline/bt-oneline-2.png" alt="Bluetooth oneliner">&lt;/p>
&lt;p>Aquí viene el primer problema. Como quiero redirigir la salida de esto, el modo interactivo no me sirve. En Bash (y en otras shells como Zsh, la que uso yo), un &lt;code>--&lt;/code> indica el fin de comandos, tras lo cual solo se puede pasar párametros. Por lo que, si se pone lo siguiente:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>bluetoothctl -- scan on
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://ander94lakx.github.io/static/images/bt-oneline/bt-oneline-3.png" alt="Bluetooth oneliner">&lt;/p>
&lt;p>Ya devuelve todo por salida estándar y sin modo interactivo.&lt;/p>
&lt;p>El siguiente paso es realizar alguna transformación. De primeras, me interesa cortar algunos parámetros, volcar esto y filtrar algunas líneas en función de su contenido. Para esto ya se que lo mejor es usar el avanzado pero intimidante &lt;code>awk&lt;/code>. He visto algunos &lt;a href="https://www.youtube.com/watch?v=W5kr7X7EG4o">videos&lt;/a> sobre él pero no lo he usado nunca más allá de copiapegas. Simplemente por probar, he probado a usar la opción para imprimir lo que devuelve, de la siguiente manera.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>bluetoothctl -- scan on | awk &lt;span style="color:#e6db74">&amp;#39;{print}&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://ander94lakx.github.io/static/images/bt-oneline/bt-oneline-4.png" alt="Bluetooth oneliner">&lt;/p>
&lt;p>Mierda. Otro problema. No sale nada. Mirando en internet, veo que el motivo es un tema de buffers. Como la salida es continua, hasta que no se libera el buffer de &lt;code>bluetoothctl&lt;/code> la salida no se redirige a &lt;code>awk&lt;/code>, por lo que no sirve. También mirando en internet, veo que puedo solucionar esto con &lt;code>stdbuf&lt;/code> y unos argumentos concretos.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>stdbuf -oL bluetoothctl -- scan on | awk &lt;span style="color:#e6db74">&amp;#39;{print}&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://ander94lakx.github.io/static/images/bt-oneline/bt-oneline-5.png" alt="Bluetooth oneliner">&lt;/p>
&lt;p>(No voy a entrar en la explicación detallada de todos los comandos y argumentos, ya que nunca lo voy a poder hacer tan bien como &lt;code>man&lt;/code> u otros internautas anónimos).&lt;/p>
&lt;p>Bien, ahora sí que funciona, así que podemos ponernos serios. Para mostrar solo ciertas partes, se puede usar la sintáxis de dólar, que permite seleccionar ciertos párametros en cada línea de entrada.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>stdbuf -oL bluetoothctl -- scan on &lt;span style="color:#ae81ff">\ &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> | awk &lt;span style="color:#e6db74">&amp;#39;{print $1 &amp;#34;,&amp;#34; $3 &amp;#34;,&amp;#34; $4}&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://ander94lakx.github.io/static/images/bt-oneline/bt-oneline-6.png" alt="Bluetooth oneliner">&lt;/p>
&lt;p>Seleccionando el primero, el tercero y el cuarto, se muestran sólamente esos campos. Por defecto, el separador es el espacio, pero si se quiere explicitar o usar cualquier otro, se puede indicar con &lt;code>-F&lt;/code>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>stdbuf -oL bluetoothctl -- scan on &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> | awk -F&lt;span style="color:#e6db74">&amp;#39;[ ]&amp;#39;&lt;/span> &lt;span style="color:#e6db74">&amp;#39;{print $1 &amp;#34;,&amp;#34; $3 &amp;#34;,&amp;#34; $4}&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://ander94lakx.github.io/static/images/bt-oneline/bt-oneline-7.png" alt="Bluetooth oneliner">&lt;/p>
&lt;p>Sabiendo como coger campos, ahora lo que me interesa es coger solo ciertas líneas. Se pueden establecer condiciones para ciertas lineas. Se que las líneas que me interesan son las que tienen &amp;ldquo;Device&amp;rdquo; en el segundo parámetro. Para poner esto en &lt;code>awk&lt;/code>, se expresa antes del comando &lt;code>print&lt;/code> de la siguiente manera:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>stdbuf -oL bluetoothctl -- scan on &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> | awk -F&lt;span style="color:#e6db74">&amp;#39;[ ]&amp;#39;&lt;/span> &lt;span style="color:#e6db74">&amp;#39;$2 ~ /Device/ {print $1 &amp;#34;,&amp;#34; $3 &amp;#34;,&amp;#34; $4}&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://ander94lakx.github.io/static/images/bt-oneline/bt-oneline-8.png" alt="Bluetooth oneliner">&lt;/p>
&lt;p>Incluso se pueden poner varias condiciones, cada una con su regex. En mi caso las líneas que me interesan son las que tengan un &lt;code>[NEW]&lt;/code> o un &lt;code>[DEL]&lt;/code>, que es lo que determina cuando se encuentra un dispositivo y cuando se deja de detectar. Esto, junto a lo de &amp;ldquo;Device&amp;rdquo;, limita perfectamente lo que intento monitorizar. Para poner esto, se pone con &lt;code>&amp;amp;&amp;amp;&lt;/code> y limitando las condiciones entre paréntesis. Como lo que se usan son regex, se usa el single pipe (&lt;code>|&lt;/code>) para decir que vale cualquiera de esos dos valores, quedando así:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>stdbuf -oL bluetoothctl -- scan on &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> | awk -F&lt;span style="color:#e6db74">&amp;#39;[ ]&amp;#39;&lt;/span> &lt;span style="color:#e6db74">&amp;#39;($2 ~ /Device/ &amp;amp;&amp;amp; $1 ~ /[NEW]|[DEL]/) {print $1 &amp;#34;,&amp;#34; $3 &amp;#34;,&amp;#34; $4}&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://ander94lakx.github.io/static/images/bt-oneline/bt-oneline-11.png" alt="Bluetooth oneliner">&lt;/p>
&lt;p>De momento ya va bastante bien, pero de poco me sirve un log si esto no tiene timestamps. &lt;code>awk&lt;/code> es tan potente que puedes usar algunas fuciones dentro de él (no sé si esto es built-in de &lt;code>awk&lt;/code> o no, pero alucinante). En este caso, añado a mi &lt;code>print&lt;/code> una llamada a &lt;code>strftime()&lt;/code> con el formato que me gusta, de la siguiente manera:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>stdbuf -oL bluetoothctl -- scan on &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> | awk -F&lt;span style="color:#e6db74">&amp;#39;[ ]&amp;#39;&lt;/span> &lt;span style="color:#e6db74">&amp;#39;($2 ~ /Device/ &amp;amp;&amp;amp; $1 ~ /[NEW]|[DEL]/) {print strftime(&amp;#34;%Y/%m/%d-%H:%M:%S-%Z&amp;#34;, systime()) &amp;#34;,&amp;#34; $1 &amp;#34;,&amp;#34; $3 &amp;#34;,&amp;#34; $4}&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://ander94lakx.github.io/static/images/bt-oneline/bt-oneline-10.png" alt="Bluetooth oneliner">&lt;/p>
&lt;p>A estas alturas ya estoy sorprendido de lo que se puede hacer con una única linea y juntando comandos (la de lineas de Python que me he ahorrado con esto). Ya, lo ultimo que me falta es volcarlo a un archivo.&lt;/p>
&lt;p>Algo que me interesaba era volcarlo a un archivo pero ir viendo al mismo tiempo la salida. Para esto &lt;code>tee&lt;/code> viene perfecto. Pasamos la salida de &lt;code>awk&lt;/code> a &lt;code>tee&lt;/code> con un pipe y listo:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>stdbuf -oL bluetoothctl -- scan on &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> | awk -F&lt;span style="color:#e6db74">&amp;#39;[ ]&amp;#39;&lt;/span> &lt;span style="color:#e6db74">&amp;#39;($2 ~ /Device/ &amp;amp;&amp;amp; $1 ~ /[NEW]|[DEL]/) {print strftime(&amp;#34;%Y/%m/%d-%H:%M:%S-%Z&amp;#34;, systime()) &amp;#34;,&amp;#34; $1 &amp;#34;,&amp;#34; $3 &amp;#34;,&amp;#34; $4}&amp;#39;&lt;/span> | tee -a bluetooth_scan_log.txt
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://ander94lakx.github.io/static/images/bt-oneline/bt-oneline-12.png" alt="Bluetooth oneliner">&lt;/p>
&lt;p>Mierda. No funciona. Pero espera, esto ya nos suena. Tenemos entre &lt;code>awk&lt;/code> y &lt;code>tee&lt;/code> el mismo problema que teníamos con &lt;code>bluetoothctl&lt;/code> y &lt;code>awk&lt;/code>, así que probamos a solucionarlo de la misma manera y listo:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>stdbuf -oL bluetoothctl -- scan on &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> | stdbuf -oL awk -F&lt;span style="color:#e6db74">&amp;#39;[ ]&amp;#39;&lt;/span> &lt;span style="color:#e6db74">&amp;#39;($2 ~ /Device/ &amp;amp;&amp;amp; $1 ~ /[NEW]|[DEL]/) {print strftime(&amp;#34;%Y/%m/%d-%H:%M:%S-%Z&amp;#34;, systime()) &amp;#34;,&amp;#34; $1 &amp;#34;,&amp;#34; $3 &amp;#34;,&amp;#34; $4}&amp;#39;&lt;/span> &lt;span style="color:#ae81ff">\
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">&lt;/span> | tee -a bluetooth_scan_log.txt
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://ander94lakx.github.io/static/images/bt-oneline/bt-oneline-13.png" alt="Bluetooth oneliner">&lt;/p>
&lt;p>Y listo. Ya tenemos todo el sistema montado. Una vez hecho, he visto que hay varios detalles que corregir, como que quizás coger justo esos parametros no es buena idea ya que el cuarto parametro puede cortarse con espacios, o que igual no me interesa filtrar tanta información.&lt;/p>
&lt;p>De todas maneras, eso no es lo importante. Lo esencial es que, con unos comandos, un poco de prueba error y nuestros amigos Google y &lt;code>man&lt;/code>, se puede montar muchas cosas, sin tener que hacer scripts ni nada. Esto tiene varias ventajas:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Usar herramientas estándar, que están disponibles en la mayoría de distribuciones Linux, lo que asegura poder usarlo en cualquier lado.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Menos scripting. Que no me malinterpretéis, me encanta programar, pero para qué hacerlo si ya hay comandos sólidos y probados que permiten hacerlo. No hay que reinventar la rueda, &lt;em>Keep It Simple, Stupid!&lt;/em>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Poder ponerlo como alias (o función &lt;em>oneline&lt;/em> si las comillas dan muchos problemas) en un &lt;code>.bashrc&lt;/code> (o &lt;code>.zshrc&lt;/code> en mi caso). Ejecutar esto escribiendo una sola palabra te hace sentir muy poderoso.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>Y esto es todo. Sé que, y me he dado cuenta mientras lo hacía, de que hay muchas maneras de mejorar esto. Algunas las he visto, de otras no me habré dado ni cuenta. Mi intención con esto es simplemente mostrar la belleza y la magia de usar herramientas estándar y la terminal, y lo potentes que son este tipo de herramientas para hacer muchas cosas que, al final, no necesitan ser programadas.&lt;/p>
&lt;p>Siempre que vayáis hacer alguna cosa del estilo, plantearos si alguien sería capaz de hacer esto con un comando. Si la respuesta a esa pregunta es sí, buscadlo y, si no lo encontráis, abrid la terminal.&lt;/p>
&lt;p>&lt;em>Happy Hacking!&lt;/em>&lt;/p></content></item></channel></rss>