---
title: "Análisis de malware (III) - Análisis estático: formato de un binario PE32, entropía e indicadores de técnicas de ofuscación"
date: 2022-12-10T18:30:00+01:00
tags: ["análisis de malware", "ransomware", "vm", "pe32", "metadatos"]
draft: true
---

Aupa! Aspaldiko! Como se suele decir, mejor tarde que nunca (tres meses, madre mía...) , asi que aqui estoy de nuevo con otra entrega de esta serie. Mal por mi parte por parar cuando realmente ibamos a meternos en harina, pero al fin ha llegado el momento.

Para refrescar la memoria, hasta ahora estamos en un punto en el que:
- Hemos montado un entorno para analizar malware.
- Hemos obtenido una muestra de malware.
- Hemos empezado a realizar operaciones básicas sobre esa muestra.

En realidad, lo que se ha hecho hasta ahora es muy básico. Si queremos obtener informacion de una muestra de malware, de un binario, necesitamos algo mas que ejecutar programas para extraer informacion de el. Necesitamos comprender como se estructura un binario. De la misma manera que una imagen, un archivo de audio o un PDF tienen un formato concreto, para los binarios no deja de ser lo mismo. Tienen un formato y estructura concreto, y comprenderla nos permite entender como estan montados y donde tenemos que mirar.

# Estructura de un binario PE32

Una muestra de malware que venga como .exe probablemente se trate de un archivo binario ejecutable (aunque no tiene porqué). Hay muchos tipos de binarios. Los binarios que contienen código los solemos ver con extensiones como .exe, .dll, .so, etc. Algunos de estos binarios de código se pueden ejecutar por si mismos (como los que vienen con extension .exe), mientras que otros son librerías compiladas para ser usadas por otros programas (como los .so de *nix o los .dll de Windows).

Aunque he mencionado extensiones, esto no indica el formato del binario en sí. La extensión de un archivo no deja de ser parte de su nombre, y por lo tanto no es informacion del archivo en si sino del sistema de ficheros. Si cambias el nombre de un archivo de .exe a .pdf no cambias el archivo, pero le indicas al sistema que es de otro tipo, por lo que puede, por ejemplo, asociarlo a otro programa y, cuando se abra, abrirse de manera incorrecta.

El formato de un archivo suele ir definido en el propio archivo en sí. Los primeros bytes de muchos formatos de archivo, entre ellos los binarios, suelen definir de que tipo es. A esto se le conoce como firma. Asi que, por mucho que cambies la extension, el archivo seguira siendo el mismo.

De hecho, una forma facil de saber que tipo de archivo tenemos entre manos, es mirar esto, ya que la extensión no es una forma fiable de ver esto.

Como cualquier otro tipo de arhivo, un archivo binario va a tener sus bits organizados de cierta manera para que el sistema operativo pueda entender el archivo y ejecutar su código. Los formatos más comunes para binarios con codigo ejecutable son los PE (Portable Executable) de Windows, los ELF de sistemas Linux y similares y los Mach-O de macOS.

En este caso, como lo que tenemos entre manos es una muestra de un binario para Windows, usa el formato PE. El formato en sí es complejo de entender y tienen muchos campos diferentes.

[![Formato PE](/static/images/malware-3-pe-format.png "Formato de un PE")](https://en.wikipedia.org/wiki/Portable_Executable#/media/File:Portable_Executable_32_bit_Structure_in_SVG_fixed.svg)

La imagen es un caos, pero no es necesario entenderla. La idea general con la que hay que quedarse es que un binario tiene una estructura y que se divide en diferentes secciones. Las primeras secciones suelen ser headers que definen el archivo y contienen información para poder interpretarlo. Después contienen la tabla de secciones, que indica que secciones tiene el binario y, por ultimo, las diferentes secciones en sí. Para los PE, las secciones principales suelen ser las siguientes:

- `.text`: el nombre confunde, ya que es la sección donde se encuentra el código en sí. Este código es código máquina que se puede ejecutar.
- `.data`: esta sección contiene datos para el binario. Pueden ser de todo tipo y se pueden modificar en ejecución.
- `.rdata`: como la sección data, pero solo de lectura.
- `.idata`: aunque a veces se incluye dentro de `.data`, esta sección contiene la IAT (Import Address Table), que es básicamente la tabla de funciones que utiliza el binario. Las funciones que importa pueden dar pistas sobre las capacidades que tiene el binario.
    - Las funciones que aparecen aqui pueden no ser todas las funciones que el binario utiliza. Hay mecanismos de empaquetado y ofuscacion que buscan, precisamente, ocultar funciones utilizadas por un binario para que dificultar adivinar lo que hace cuando se analiza el archivo.
    - En ficheros .dll suele ser común encontrar la sección `.edata`, que es la tabla de funciones que exporta esa librería para ser utilizadas por otros binarios.
- `.rsrc`: los diferentes recursos. Pueden ser audio, iconos, fuentes, etc. Si el programa hace uso de algún recurso que no obtiene desde fuera (otro archivo, máquina o desde internet), es porque está aquí dentro. También puede dar pistas del comportamiento.

Lo esencial es que, de esa estructura se puede sacar información sobre el tipo de archivo que es y lo que es capaz de hacer, sin tener que entrar en el detalle de su código. Hay aplicaciones, como PEStudio, que leen esta estructura, muestran información que recogen de esta estructura y seccioness y analizan esa información, por lo que se suelen usar para realizar este tipo de análisis.

![Info Básica PE](/static/images/malware-3-pe-basic.png "Información básica del PE")

PEStudio en particular no solo recoge información sobre la estructura del binario, sino que también hace búsqueda de strings o recoge metadatos, entre otros. Además, depende de lo que encuentre en este tipo de información (metadatos, strings, secciones del binario, etc.) da una serie de indicadores que nos dan información sobre el binario.

![Secciones del binario en PEStudio](/static/images/malware-3-info-sections.png "Secciones del binario en PEStudio")

Aquí ya podemos ver que estructura tiene. En efecto, no solo es un binario PE32 sino que además tiene las típicas secciones (`.text`, `.data`, `.rdata`, `.rsrc`). PEStudio es capaz de sacar mas información de la tabla de secciones, como la entropía o las diferentes propiedades. Esto puede aportar información sobre la muestra que se analiza.

# Detección de mecanismos de ofuscación

Vale, genial, pero qué nos puede aportar analizar la estructura de un binario?

Uno de los objetivos principales durante el análisis estático de un malware consiste en ver si esta ofuscado o empaquetado de alguna manera. El malware no deja de ser software, y un malware compilado no deja de ser un puñado de código maquina que se puede desensamblar y decompilar. Cuando alguien desarrolla malware con motivos maliciosos, suele buscar dos cosas: a) evadir las medidas defensivas para infectar a sus objetivos y b) ocultar su comportamiento para hacer que sea más dificil de analizar. Para ello, siempre que se desarrolla malware se busca implementar algún tipo de técnica de ofuscación o empaquetado para que los sistemas de defensa no sean capaces de detectarlo y para dificultar su análisis. 

Detectar si tiene mecanismos de ofuscación y cuales son es importante como paso previo a analizar su código. Si esta ofuscado, el código puede no tener sentido y su análisis puede dificultarse bastante. Detectar esto antes permite tomar decisiones sobre como realizar otras técnicas de análisis.

Pero a lo que iba. En este caso PEStudio nos muestra cosas interesantes. La primera de todas, y la más interesante, el el hecho de que la sección de código (`.text`) es "self-modifying". ¿Esto qué significa? Significa que el código que hay en esa sección modifica información de la misma sección.

Esto en si ya es sospechoso. Los binarios tienen varias secciones precisamente para diferenciar entre lo que es código y lo que son datos. Para datos hay diferentes secciones para diferenciar entre lo que es solo de lectura y lo que es modificable. Lo habitual es que, un programa, ejecute su código y vaya accediendo a las zonas de memoria de datos para obtener información, no a su propia sección de código. Si accede a la parte de la memoria donde se aloja su mismo código, es porque pretende modificarlo. Gran parte de los mecanismos de ofuscación se basan en esto, sistemas que se ejecutan, desempaquetan su codigo real y lo sustituyen por el codigo original. Así, desde fuera, parece un programa inocuo pero, cuando se ejecuta, ejecuta nuevo código que originalmente no se veía en el binario. En este punto esto es solo un indicativo de que puede estar ofuscado.

## Detección de packers

Por otro lado, con respecto a si esta empaquetado, es necesario aclarar en que consiste. Los empaquetadores son sistemas que permiten comprimir y reducir un binario para que ocupe menos. Esto se traduce en todo un sistema que, cuando se ejecuta, despliega su codigo real y realiza el desempaquetado necesario para poder ejecutar el código original. Estos "packers" se pueden utilizar tanto como forma de comprimir ejecutables y hacerlos mas ligeros (a costa de que sean algo mas lentos de arrancar por todo ese proceso de desempaquetado) o, como ya habréis podido deducir, como forma de ofuscación. Existen empaquetadores bastante famosos como UPX.

Detectar packers estándar es relativaemnte sencillo, poruqe estos packers crean sus propias estructuras y secciones claramente definidas en el binario. Por ello, el análisis de las secciones permite detectar de un vistazo si se hace uso de alguno de estos. En este caso no parece que se use ningun packer común, ya que las secciones son estándar. Esto puede implicar que, en caso de usar mecanismos de ofuscación, no es un mecanismo tan estándar.

Hasta ahora, con lo que hemos visto, tenemos sospechas de que puede estar ofuscado, pero la verdad es que no tenemos certeza ninguna de ello. Siempre se puede a entrar a analizar el código y ver que nos cuenta, pero todavia tenemos mas formas de poder detectar posibles mecanismos de ofuscacion sin tener que leer codigo.

# Entropía

Tremenda palabra. Se usa mal tanto en fisica como en informática. Para el que quiera la frikada, tiene la [WIkipedia](https://en.wikipedia.org/wiki/Entropy_(information_theory)#Characterization), pero en esencia (y por seguir la tendencia de explicarlo brevemente y mal) consiste en una forma de ver la cantidad de información propmedio en un archivo. Normalmente, se mide en una escala (suele ser algo como entre 0-1 o a veces tambien entre 0-8, no me preguntéis por qué), y nos permite ver cuanta informacion hay.

Hay herramientas que permiten hacer esto con binarios, y esta muy bien porque permite ver la entropia a lo largo de todo el archivo. La gracia de esto es que, niveles mayores o menores de informacion pueden indicar diferenes cosas. El que la entropia sea muy alta puede indicar ofuscación o empaquetado, ya que se concentra mucha informacion en un punto concreto. El que la entropia sea baja puede indicar zonas vacias, con poco interes donde no hay nada especial, indicando huecos (que igual estan pensados para llenarse en tiempo de ejecución). Un nivel de entropia medio indica que hay informacion, pero no muy concentrada. Os pongo una tabla sobre niveles de entropia comunes (0-8) para diferentes tipos de archivos, que [unos señores muy majos](https://doi.org/10.1109/MSP.2007.48) tuvieron a bien analizar en su momento.

| Datasets                 | Entropía media | Entropía máxima |
|:-------------------------|:--------------:|:---------------:|
| Texto plano              | 4,347          | 4,715           |
| Ejecutables nativos      | 5,099          | 6,227           |
| Ejecutables empaquetados | 6,801          | 7,233           |
| Ejecutables cifrados     | 7,175          | 7,303           |



# Más artículos

- [Análisis de malware (I) - Cómo empezar a analizar malware](../2022-01-26-malware-analysis-1)
- [Análisis de malware (II) - Análisis estático básico: strings y metadatos](../2022-09-11-malware-analysis-2)
- Análisis de malware (III) - Análisis estático: formato de un binario PE32, entropía e indicadores de técnicas de ofuscación
- ...
